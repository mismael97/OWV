#ifndef SIGNALSELECTIONDIALOG_H
#define SIGNALSELECTIONDIALOG_H

#include <QDialog>
#include <QTreeWidget>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QDialogButtonBox>
#include <QLineEdit>
#include <QLabel>
#include <QProgressBar>
#include <QMap>
#include <QSet>
#include <QTimer>
#include <QFuture>
#include <QFutureWatcher>
#include <QtConcurrent>
#include "vcdparser.h"

class SignalSelectionDialog : public QDialog
{
    Q_OBJECT
public:
    explicit SignalSelectionDialog(QWidget *parent = nullptr);
    ~SignalSelectionDialog();

    void setAvailableSignals(const QVector<VCDSignal> &allSignals, const QList<VCDSignal> &visibleSignals);
    QList<VCDSignal> getSelectedSignals() const;

protected:
    void closeEvent(QCloseEvent *event) override;
    void showEvent(QShowEvent *event) override;

private slots:
    void onScopeItemChanged(QTreeWidgetItem *item, int column);
    void selectAll();
    void deselectAll();
    void onSearchTextChanged(const QString &text);
    void onItemExpanded(QTreeWidgetItem *item);
    void onItemChanged(QTreeWidgetItem *item, int column);
    void onItemClicked(QTreeWidgetItem *item, int column);
    void onSearchTimerTimeout();
    void onLoadProgress(int percentage);
    void onLoadFinished();
    
    // NEW: Filter button slots
    void onFilterInputPorts();
    void onFilterOutputPorts();
    void onFilterInoutPorts();
    void onFilterNetSignals();
    void onFilterRegisters();
    void onFilterAll();

private:
    void processNextChunk();
    void populateTopLevelScopes();
    void performSearch(const QString &text);
    void populateScopeChildren(const QString &scopePath, QTreeWidgetItem *parentItem);
    void displaySearchResults(const QString &text, int matches, const QMap<QString, QVector<VCDSignal>> &matchingSignalsByScope);
    void onSearchFinished();
    void applySignalFilter();

    // UI Components
    QTreeWidget *signalTree;
    QPushButton *selectAllButton;
    QPushButton *deselectAllButton;
    QDialogButtonBox *buttonBox;
    QLineEdit *searchEdit;
    QProgressBar *progressBar;
    QLabel *statusLabel;

    // NEW: Filter buttons
    QPushButton *filterInputButton;
    QPushButton *filterOutputButton;
    QPushButton *filterInoutButton;
    QPushButton *filterNetButton;
    QPushButton *filterRegButton;
    QPushButton *filterAllButton;

    // Loading and search management
    QTimer *searchTimer;
    QString pendingSearchText;
    bool isSearchInProgress;
    bool isLoadingInProgress;
    bool isInitialLoadComplete;

    // Loading state variables
    int currentLoadIndex;
    int totalSignalsToProcess;

    // Data storage with caching
    QVector<VCDSignal> allSignals;
    QSet<QString> visibleSignalIdentifiers;
    QSet<QString> selectedSignals;

    // Scope structure with loading state
    QMap<QString, QVector<VCDSignal>> scopeSignals;
    QMap<QString, QStringList> childScopes;
    QSet<QString> populatedScopes;
    QSet<QString> loadingScopes; // Scopes currently being loaded

    // Multi-selection support
    QTreeWidgetItem *lastSelectedItem;
    QString currentFilter;
    
    // NEW: Signal type filter
    QString currentTypeFilter;

    // Async loading
    QFutureWatcher<void> *loadWatcher;
    QFuture<void> loadFuture;

    // Methods
    void startInitialLoad();
    void performInitialLoad();
    void buildScopeStructure();
    void populateTopLevelScopesLazy();
    void buildScopeStructureChunked();
    void populateScopeChildrenLazy(const QString &scopePath, QTreeWidgetItem *parentItem);
    void updateScopeCheckState(QTreeWidgetItem *scopeItem);
    void updateParentScopeCheckState(QTreeWidgetItem *childItem);
    void setScopeSignalsSelection(const QString &scopePath, bool selected);
    void updateTreeWidgetCheckStates(const QString &scopePath, bool selected);
    void handleMultiSelection(QTreeWidgetItem *item);
};

#endif // SIGNALSELECTIONDIALOG_H#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QTreeWidget>
#include <QSplitter>
#include <QToolBar>
#include <QStatusBar>
#include <QFileDialog>
#include <QMessageBox>
#include <QScrollBar>
#include <QLabel>
#include <QPushButton>
#include <QHBoxLayout>
#include <QWidget>
#include <QListWidget>
#include <QListWidgetItem>
#include <QDialog>
#include <QDialogButtonBox>
#include <QKeyEvent>
#include <QComboBox> // ADD THIS
#include "vcdparser.h"
#include "waveformwidget.h"
#include <QProcess>

class SignalSelectionDialog;

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

protected:
    void keyPressEvent(QKeyEvent *event) override;

private slots:
    void setLineThicknessThin();
    void setLineThicknessMedium();
    void openFile();
    void zoomIn();
    void zoomOut();
    void zoomFit();
    void updateTimeDisplay(int time);
    void about();
    void showAddSignalsDialog();
    void removeSelectedSignals();
    void toggleBusDisplayFormat();
    void resetSignalColors();
    void setBusHexFormat();
    void setBusBinaryFormat();
    void setBusOctalFormat();
    void setBusDecimalFormat();
    void updateBusFormatActions();
    void increaseSignalHeight();
    void decreaseSignalHeight();

    // NEW SLOTS:
    void onNavigationModeChanged(int index);
    void onPrevValueClicked();
    void onNextValueClicked();

private:
    QString currentVcdFilePath;
    QString tempVcdFilePath;
    bool hasRtlDirectory;
    void closeEvent(QCloseEvent *event);

    bool processVcdWithRtl(const QString &vcdFile);
    QString findRtlDirectory(const QString &vcdFile);
    bool runVcdPortMapper(const QString &inputVcd, const QString &outputVcd, const QString &rtlDir);

    void showRtlDirectoryDialog();
    void createToolbarBelowMenu();
    void updateLineThicknessActions();
    QAction *increaseHeightAction;
    QAction *decreaseHeightAction;

    QMenu *lineThicknessMenu;
    QAction *lineThinAction;
    QAction *lineMediumAction;
    QAction *lineThickAction;
    // Wave menu actions
    QMenu *waveMenu;
    QAction *defaultColorsAction;
    QMenu *busFormatMenu;
    QAction *busHexAction;
    QAction *busBinaryAction;
    QAction *busOctalAction;
    QAction *busDecimalAction;
    QAction *resetColorsAction;
    void createActions();
    void createToolBar();
    void createStatusBar();
    void setupUI();
    void loadVcdFile(const QString &filename);
    void loadDefaultVcdFile();

    void createMenuBar();
    void createMainToolbar();
    void setupNavigationControls(); // ADD THIS
    void updateNavigationButtons(); // ADD THIS

    // Add these to private section
    QToolBar *mainToolBar;
    QLineEdit *searchField;

    // Navigation controls
    QComboBox *navigationModeCombo;
    QPushButton *prevValueButton;
    QPushButton *nextValueButton;

    // UI Components
    WaveformWidget *waveformWidget;
    QScrollBar *timeScrollBar;

    // Toolbar Actions
    QAction *openAction;
    QAction *zoomInAction;
    QAction *zoomOutAction;
    QAction *zoomFitAction;
    QAction *aboutAction;

    // Bottom controls
    QPushButton *addSignalsButton;
    QPushButton *removeSignalsButton;

    // Status Bar
    QLabel *statusLabel;
    QLabel *timeLabel;

    // Data
    VCDParser *vcdParser;
};

#endif // MAINWINDOW_H#ifndef VCDPARSER_H
#define VCDPARSER_H

#include <QObject>
#include <QString>
#include <QVector>
#include <QMap>
#include <QFile>
#include <QTextStream>
#include <QSet>

struct VCDSignal {
    QString identifier;
    QString name;
    QString scope;
    int width;
    QString type;
    QString fullName;  // ADD THIS: unique identifier for the signal

    bool operator==(const VCDSignal& other) const {
        return fullName == other.fullName;  // Compare using fullName instead of identifier
    }
};

Q_DECLARE_METATYPE(VCDSignal)

struct VCDValueChange {
    int timestamp;
    QString value;
};

class VCDParser : public QObject
{
    Q_OBJECT

public:
    explicit VCDParser(QObject *parent = nullptr);
    ~VCDParser();

    bool parseFile(const QString &filename);
    bool parseHeaderOnly(const QString &filename); // Fast header-only parsing
    QString getError() const { return errorString; }

    const QVector<VCDSignal>& getSignals() const { return vcdSignals; }
    QVector<VCDValueChange> getValueChangesForSignal(const QString &fullName);  // CHANGE: use fullName
    const QMap<QString, VCDSignal>& getIdentifierMap() const { return identifierMap; }
    const QMap<QString, VCDSignal>& getFullNameMap() const { return fullNameMap; }  // ADD THIS
    int getEndTime() const { return endTime; }
    
    // Load specific signals on demand
    bool loadSignalsData(const QList<QString> &fullNames);  // CHANGE: use fullNames

private:
    bool parseHeader(QTextStream &stream);
    bool parseValueChangesForSignals(QTextStream &stream, const QSet<QString> &signalsToLoad);
    void parseScopeLine(const QString &line);
    void parseVarLine(const QString &line);
    void parseTimescale(const QString &line);
    QString generateFullName(const QString &scope, const QString &name);  // ADD THIS

    QString errorString;
    QVector<VCDSignal> vcdSignals;
    QMap<QString, VCDSignal> identifierMap;
    QMap<QString, VCDSignal> fullNameMap;  // ADD THIS: maps fullName -> VCDSignal
    
    // Data storage
    QMap<QString, QVector<VCDValueChange>> valueChanges;
    QSet<QString> loadedSignals; // Track which signals have data loaded
    
    QString currentScope;
    int endTime;
    QString timescale;
    QString vcdFilename;
};

#endif // VCDPARSER_H#ifndef WAVEFORMWIDGET_H
#define WAVEFORMWIDGET_H

#include <QWidget>
#include <QPainter>
#include <QScrollBar>
#include <QWheelEvent>
#include <QMouseEvent>
#include <QVector>
#include <QList>
#include <QLabel>
#include <QMenu>
#include <QContextMenuEvent>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QSet>
#include <QInputDialog>
#include <QColorDialog>

#include "vcdparser.h"

// Simple signal display structure
struct DisplaySignal
{
    VCDSignal signal;
};

// Space structure
struct DisplaySpace
{
    QString name;
};

// Unified display item
struct DisplayItem
{
    enum Type
    {
        Signal,
        Space
    };
    Type type;

    // Only one of these is valid based on type
    DisplaySignal signal;
    DisplaySpace space;

    // Constructor for signal
    static DisplayItem createSignal(const VCDSignal &sig)
    {
        DisplayItem item;
        item.type = Signal;
        item.signal = {sig};
        return item;
    }

    // Constructor for space
    static DisplayItem createSpace(const QString &name = "")
    {
        DisplayItem item;
        item.type = Space;
        item.space = {name};
        return item;
    }

    QString getName() const
    {
        switch (type)
        {
        case Signal:
        {
            QString name = signal.signal.scope.isEmpty() ? signal.signal.name : signal.signal.scope + "." + signal.signal.name;
            // Remove any width information like "[3:0]" from the name
            int bracketPos = name.indexOf('[');
            if (bracketPos != -1)
            {
                name = name.left(bracketPos).trimmed();
            }
            return name;
        }
        case Space:
            return space.name.isEmpty() ? "⏐" : "⏐ " + space.name;
        }
        return "";
    }

    // Helper function to get full scope path for searching
    QString getFullPath() const
    {
        if (type == Signal)
        {
            QString fullPath = signal.signal.scope.isEmpty() ? signal.signal.name : signal.signal.scope + "." + signal.signal.name;
            // Remove any width information for consistency
            int bracketPos = fullPath.indexOf('[');
            if (bracketPos != -1)
            {
                fullPath = fullPath.left(bracketPos).trimmed();
            }
            return fullPath;
        }
        return getName();
    }

    int getHeight() const
    {
        // Use reasonable default heights - these will be overridden by the actual drawing functions
        // The actual drawing will use the configurable heights from WaveformWidget
        switch (type)
        {
        case Signal:
            return 30; // Default height for signals
        case Space:
            return 30; // Fixed height for spaces
        }
        return 30;
    }

    bool isSelectable() const { return true; }
    bool isMovable() const { return true; }
};

class WaveformWidget : public QWidget
{
    Q_OBJECT

public:
    int getCursorTime() const { return cursorTime; }
    void navigateToTime(int time);
    enum NavigationMode
    {
        ValueChange,
        SignalRise,
        SignalFall
    };
    void setNavigationMode(NavigationMode mode);
    void navigateToPreviousEvent();
    void navigateToNextEvent();
    bool hasPreviousEvent() const;
    bool hasNextEvent() const;

    void selectSignalAtPosition(const QPoint &pos);

    void ensureSignalLoaded(const QString &identifier);
    void searchSignals(const QString &searchText);
    void clearSearch();

    // Add these to the public section of WaveformWidget class
    int getSignalHeight() const { return signalHeight; }
    int getLineWidth() const { return lineWidth; }
    void setSignalHeight(int height)
    {
        signalHeight = qMax(5, qMin(50, height)); // Clamp between 5 and 50
        update();
    }
    void setLineWidth(int width)
    {
        lineWidth = qMax(1, qMin(5, width)); // Clamp between 1 and 5
        update();
    }
    enum BusFormat
    {
        Hex,
        Binary,
        Octal,
        Decimal
    };

    explicit WaveformWidget(QWidget *parent = nullptr);
    void setVcdData(VCDParser *parser);
    void setVisibleSignals(const QList<VCDSignal> &visibleSignals);
    void zoomIn();
    void zoomOut();
    void zoomFit();
    void removeSelectedSignals();
    void selectAllSignals();
    void resetSignalColors();
    void setBusDisplayFormat(BusFormat format);
    BusFormat getBusDisplayFormat() const { return busDisplayFormat; }
    int getSelectedSignal() const { return selectedItems.isEmpty() ? -1 : *selectedItems.begin(); }
    QList<int> getSelectedItemIndices() const { return selectedItems.values(); }

    // Item management
    int getItemCount() const { return displayItems.size(); }
    const DisplayItem *getItem(int index) const;

signals:
    void timeChanged(int time);
    void itemSelected(int itemIndex);
    void contextMenuRequested(const QPoint &pos, int itemIndex);
    void cursorTimeChanged(int time); // ADD THIS - for yellow timeline cursor

protected:
    void paintEvent(QPaintEvent *event) override;
    void wheelEvent(QWheelEvent *event) override;
    void mousePressEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;
    void mouseReleaseEvent(QMouseEvent *event) override;
    void resizeEvent(QResizeEvent *event) override;
    void contextMenuEvent(QContextMenuEvent *event) override;
    void keyPressEvent(QKeyEvent *event) override;
    void mouseDoubleClickEvent(QMouseEvent *event) override;

private:
    void forceNavigationUpdate();
    void debugSignalState(int time) const;
    double calculateZoomFitScale() const
    {
        if (!vcdParser || vcdParser->getEndTime() <= 0)
        {
            return 1.0;
        }

        int availableWidth = width() - signalNamesWidth - valuesColumnWidth;

        // Use the same calculation as zoomFit but just return the scale
        const int PADDING = 10;
        int totalTimeRange = vcdParser->getEndTime() + (2 * PADDING);
        totalTimeRange = qMax(20, totalTimeRange);

        if (availableWidth <= 10)
        {
            return 1.0;
        }

        double zoomFitScale = static_cast<double>(availableWidth - (2 * PADDING)) / vcdParser->getEndTime();
        return qMax(0.02, qMin(50.0, zoomFitScale));
    }
    void resetNavigationForCurrentSignal();

    // void navigateToTime(int targetTime);
    int findEventIndexForTime(int time, const QString &signalFullName) const;

    bool isSignalSelected(const VCDSignal &signal) const
    {
        for (int i = 0; i < displayItems.size(); i++)
        {
            if (selectedItems.contains(i) &&
                displayItems[i].type == DisplayItem::Signal &&
                displayItems[i].signal.signal.fullName == signal.fullName)
            {
                return true;
            }
        }
        return false;
    }
    int selectedLineWidth = 3;

    // Navigation
    QMap<QString, QVector<int>> signalEventTimestamps; // Maps signal fullName to its events
    QMap<QString, int> signalCurrentEventIndex;        // Maps signal fullName to its current event index
    QString currentlyNavigatedSignal;                  // Which signal we're currently navigating
    NavigationMode navigationMode = ValueChange;
    int currentEventIndex = -1;
    QVector<int> eventTimestamps;

    void updateEventList();
    int findEventIndexForTime(int time) const;
    int getCurrentEventTime() const;

    // Signal selection from waveform area
    void handleWaveformClick(const QPoint &pos);
    // Track which signals have been loaded to avoid reloading
    QSet<QString> loadedSignalIdentifiers;

    // Signal data cache with limits
    QMap<QString, QVector<VCDValueChange>> signalDataCache;
    const int MAX_CACHED_SIGNALS = 1000; // Limit cache size
    QStringList recentlyUsedSignals;     // For LRU cache management

    // Make sure these search methods exist:
    void handleSearchInput(const QString &text);
    void updateSearchResults();
    void applySearchFilter();
    // Add these to the private section of WaveformWidget class
    int signalHeight = 24; // Configurable signal height for both signals and buses
    int lineWidth = 1;     // Configurable line width

    // Helper methods for virtual rendering
    int calculateTotalHeight() const;
    void updateCursorTime(const QPoint &pos);
    void drawSignalNamesColumn(QPainter &painter);
    void drawSignalValuesColumn(QPainter &painter, int cursorTime);
    void drawWaveformArea(QPainter &painter);
    void drawTimeCursor(QPainter &painter);
    void drawGrid(QPainter &painter);
    void drawSignals(QPainter &painter);
    void drawSignalWaveform(QPainter &painter, const VCDSignal &signal, int yPos);
    void drawBusWaveform(QPainter &painter, const VCDSignal &signal, int yPos);
    void updateScrollBar();
    int timeToX(int time) const;
    int xToTime(int x) const;
    QString getSignalValueAtTime(const QString &identifier, int time) const;
    QString getBusValueAtTime(const QString &identifier, int time) const;
    int calculateTimeStep(int startTime, int endTime) const;
    int getItemAtPosition(const QPoint &pos) const;
    int getItemYPosition(int index) const;
    void showContextMenu(const QPoint &pos, int itemIndex);
    void addSpaceAbove(int index);
    void addSpaceBelow(int index);
    void renameItem(int itemIndex);
    QString promptForName(const QString &title, const QString &defaultName = "");
    void drawCleanTransition(QPainter &painter, int x, int top, int bottom, const QColor &signalColor);

    // Color management
    void changeSignalColor(int itemIndex);
    QColor getSignalColor(const QString &identifier) const;

    // Splitter handling
    bool isOverNamesSplitter(const QPoint &pos) const;
    bool isOverValuesSplitter(const QPoint &pos) const;
    void updateSplitterPositions();

    // Search functionality
    QString searchText;
    bool isSearchActive = false;
    bool isSearchFocused = false;
    QSet<int> searchResults;
    void drawSearchBar(QPainter &painter);

    // Drag and movement
    void startDrag(int itemIndex);
    void performDrag(int mouseY);
    void moveItem(int itemIndex, int newIndex);

    // Selection
    void handleMultiSelection(int itemIndex, QMouseEvent *event);

    // Helper methods
    bool isSignalItem(int index) const
    {
        return index >= 0 && index < displayItems.size() && displayItems[index].type == DisplayItem::Signal;
    }
    bool isSpaceItem(int index) const
    {
        return index >= 0 && index < displayItems.size() && displayItems[index].type == DisplayItem::Space;
    }
    VCDSignal getSignalFromItem(int index) const
    {
        return isSignalItem(index) ? displayItems[index].signal.signal : VCDSignal();
    }

    // Bus display helpers
    QString formatBusValue(const QString &binaryValue) const;
    bool isValidBinary(const QString &value) const;
    QString binaryToHex(const QString &binaryValue) const;
    QString binaryToOctal(const QString &binaryValue) const;
    QString binaryToDecimal(const QString &binaryValue) const;

    VCDParser *vcdParser;

    // Layout parameters
    int signalNamesWidth = 250;
    int valuesColumnWidth = 120;
    double timeScale;
    int timeOffset;
    int timeMarkersHeight;
    int topMargin;

    // Display items
    QList<DisplayItem> displayItems;

    // Signal colors
    QMap<QString, QColor> signalColors;
    BusFormat busDisplayFormat = Hex;

    // Splitter state
    bool draggingNamesSplitter = false;
    bool draggingValuesSplitter = false;

    // Drag state
    bool isDragging;
    bool isDraggingItem;
    int dragStartX;
    int dragStartOffset;
    int dragItemIndex;
    int dragStartY;
    QPoint dragStartPos;

    // Selection state
    QSet<int> selectedItems;
    int lastSelectedItem;

    // Time cursor and values display
    int cursorTime = 0;
    bool showCursor = true;

    QScrollBar *horizontalScrollBar;
    QScrollBar *verticalScrollBar;
    int verticalOffset = 0;
};

#endif // WAVEFORMWIDGET_H#include "SignalSelectionDialog.h"
#include <QHeaderView>
#include <QDebug>
#include <QApplication>
#include <QTreeWidgetItemIterator>
#include <QQueue>
#include <QCloseEvent>
#include <QShowEvent>
#include <QtConcurrent>


void SignalSelectionDialog::onSearchFinished()
{
    isSearchInProgress = false;
}

void SignalSelectionDialog::onItemChanged(QTreeWidgetItem *item, int column)
{
    if (column != 0)
        return;

    QVariant data = item->data(0, Qt::UserRole);

    if (data.canConvert<VCDSignal>())
    {
        // Signal item changed
        VCDSignal signal = data.value<VCDSignal>();
        if (item->checkState(0) == Qt::Checked)
        {
            selectedSignals.insert(signal.fullName); // CHANGE: use fullName
        }
        else
        {
            selectedSignals.remove(signal.fullName); // CHANGE: use fullName
        }

        // Update parent scope check state
        updateParentScopeCheckState(item);
    }
    else
    {
        // Scope item changed
        onScopeItemChanged(item, column);
        return;
    }

    // Update status
    statusLabel->setText(QString("%1 signal(s) selected").arg(selectedSignals.size()));
}


SignalSelectionDialog::SignalSelectionDialog(QWidget *parent)
    : QDialog(parent), lastSelectedItem(nullptr),
      isSearchInProgress(false), isLoadingInProgress(false), isInitialLoadComplete(false),
      currentLoadIndex(0), totalSignalsToProcess(0),
      currentTypeFilter("all")  // Initialize with "all" filter
{
    setWindowTitle("Add Signals to Waveform");
    setMinimumSize(800, 600);

    QVBoxLayout *mainLayout = new QVBoxLayout(this);

    // Search bar
    QHBoxLayout *searchLayout = new QHBoxLayout();
    QLabel *searchLabel = new QLabel("Search:");
    searchEdit = new QLineEdit();
    searchEdit->setPlaceholderText("Type to search signals...");
    searchEdit->setClearButtonEnabled(true);

    // Setup search timer with 300ms delay
    searchTimer = new QTimer(this);
    searchTimer->setSingleShot(true);
    searchTimer->setInterval(300);

    connect(searchEdit, &QLineEdit::textChanged, this, [this](const QString &text) {
        pendingSearchText = text;
        
        // Cancel any ongoing loading when user starts searching
        if (isLoadingInProgress && loadWatcher && loadWatcher->isRunning()) {
            loadWatcher->cancel();
            isLoadingInProgress = false;
            progressBar->setVisible(false);
        }
        
        if (text.isEmpty()) {
            searchTimer->stop();
            onSearchTextChanged(text);
        } else {
            searchTimer->start();
        }
    });

    connect(searchTimer, &QTimer::timeout, this, &SignalSelectionDialog::onSearchTimerTimeout);

    searchLayout->addWidget(searchLabel);
    searchLayout->addWidget(searchEdit);

    // NEW: Filter buttons layout
    QHBoxLayout *filterLayout = new QHBoxLayout();
    filterLayout->setSpacing(2);
    
    filterInputButton = new QPushButton("Input Ports");
    filterOutputButton = new QPushButton("Output Ports");
    filterInoutButton = new QPushButton("Inout Ports");
    filterNetButton = new QPushButton("Net Signals");
    filterRegButton = new QPushButton("Registers");
    filterAllButton = new QPushButton("All Signals");
    
    // Style the buttons
    QString buttonStyle = "QPushButton { padding: 6px; font-size: 11px; border: 1px solid #555; background-color: #333; color: white; }"
                         "QPushButton:checked { background-color: #4CAF50; color: white; border: 1px solid #4CAF50; }"
                         "QPushButton:hover { background-color: #555; }";
    
    filterInputButton->setStyleSheet(buttonStyle);
    filterOutputButton->setStyleSheet(buttonStyle);
    filterInoutButton->setStyleSheet(buttonStyle);
    filterNetButton->setStyleSheet(buttonStyle);
    filterRegButton->setStyleSheet(buttonStyle);
    filterAllButton->setStyleSheet(buttonStyle);
    
    // Make buttons checkable
    filterInputButton->setCheckable(true);
    filterOutputButton->setCheckable(true);
    filterInoutButton->setCheckable(true);
    filterNetButton->setCheckable(true);
    filterRegButton->setCheckable(true);
    filterAllButton->setCheckable(true);
    
    // Set "All Signals" as initially checked
    filterAllButton->setChecked(true);
    
    // Connect filter buttons
    connect(filterInputButton, &QPushButton::clicked, this, &SignalSelectionDialog::onFilterInputPorts);
    connect(filterOutputButton, &QPushButton::clicked, this, &SignalSelectionDialog::onFilterOutputPorts);
    connect(filterInoutButton, &QPushButton::clicked, this, &SignalSelectionDialog::onFilterInoutPorts);
    connect(filterNetButton, &QPushButton::clicked, this, &SignalSelectionDialog::onFilterNetSignals);
    connect(filterRegButton, &QPushButton::clicked, this, &SignalSelectionDialog::onFilterRegisters);
    connect(filterAllButton, &QPushButton::clicked, this, &SignalSelectionDialog::onFilterAll);
    
    filterLayout->addWidget(filterInputButton);
    filterLayout->addWidget(filterOutputButton);
    filterLayout->addWidget(filterInoutButton);
    filterLayout->addWidget(filterNetButton);
    filterLayout->addWidget(filterRegButton);
    filterLayout->addWidget(filterAllButton);
    filterLayout->addStretch();

    // Progress bar
    progressBar = new QProgressBar();
    progressBar->setVisible(false);
    progressBar->setRange(0, 100);
    progressBar->setTextVisible(true);

    // Status label
    statusLabel = new QLabel("Ready");

    // Signal tree
    signalTree = new QTreeWidget();
    signalTree->setHeaderLabels({"Signal", "Width", "Type", "Identifier"});
    signalTree->setAlternatingRowColors(true);
    signalTree->header()->setStretchLastSection(false);
    signalTree->header()->setSectionResizeMode(0, QHeaderView::Stretch);
    signalTree->header()->setSectionResizeMode(1, QHeaderView::ResizeToContents);
    signalTree->header()->setSectionResizeMode(2, QHeaderView::ResizeToContents);
    signalTree->header()->setSectionResizeMode(3, QHeaderView::ResizeToContents);
    signalTree->setSelectionMode(QAbstractItemView::ExtendedSelection);

    // Connect signals for lazy loading and selection
    connect(signalTree, &QTreeWidget::itemExpanded, this, &SignalSelectionDialog::onItemExpanded);
    connect(signalTree, &QTreeWidget::itemChanged, this, &SignalSelectionDialog::onItemChanged);
    connect(signalTree, &QTreeWidget::itemClicked, this, &SignalSelectionDialog::onItemClicked);

    // Controls
    QHBoxLayout *controlsLayout = new QHBoxLayout();
    selectAllButton = new QPushButton("Select All");
    deselectAllButton = new QPushButton("Deselect All");

    connect(selectAllButton, &QPushButton::clicked, this, &SignalSelectionDialog::selectAll);
    connect(deselectAllButton, &QPushButton::clicked, this, &SignalSelectionDialog::deselectAll);

    controlsLayout->addWidget(selectAllButton);
    controlsLayout->addWidget(deselectAllButton);
    controlsLayout->addStretch();

    // Buttons
    buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
    connect(buttonBox, &QDialogButtonBox::accepted, this, &QDialog::accept);
    connect(buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);

    mainLayout->addLayout(searchLayout);
    mainLayout->addLayout(filterLayout);  // NEW: Add filter buttons
    mainLayout->addWidget(progressBar);
    mainLayout->addWidget(statusLabel);
    mainLayout->addWidget(signalTree, 1);
    mainLayout->addLayout(controlsLayout);
    mainLayout->addWidget(buttonBox);

    // Initialize load watcher
    loadWatcher = new QFutureWatcher<void>(this);
    connect(loadWatcher, &QFutureWatcher<void>::finished, this, &SignalSelectionDialog::onLoadFinished);
}

void SignalSelectionDialog::onItemClicked(QTreeWidgetItem *item, int column)
{
    Q_UNUSED(column);

    // Only handle clicks on signal items (not scope items)
    QVariant data = item->data(0, Qt::UserRole);
    if (data.canConvert<VCDSignal>())
    {
        handleMultiSelection(item);
    }
}

void SignalSelectionDialog::handleMultiSelection(QTreeWidgetItem *item)
{
    if (!item)
        return;

    QVariant data = item->data(0, Qt::UserRole);
    if (!data.canConvert<VCDSignal>())
        return;

    VCDSignal signal = data.value<VCDSignal>();
    Qt::KeyboardModifiers modifiers = QApplication::keyboardModifiers();

    // Block signals to prevent recursive calls during bulk operations
    signalTree->blockSignals(true);

    if (modifiers & Qt::ShiftModifier && lastSelectedItem)
    {
        // Shift+click: select range from last selected to current item

        // Get all signal items in the tree
        QList<QTreeWidgetItem *> allSignalItems;
        QTreeWidgetItemIterator it(signalTree);
        while (*it)
        {
            QVariant itData = (*it)->data(0, Qt::UserRole);
            if (itData.canConvert<VCDSignal>())
            {
                allSignalItems.append(*it);
            }
            ++it;
        }

        // Find indices of last selected and current items
        int startIndex = allSignalItems.indexOf(lastSelectedItem);
        int endIndex = allSignalItems.indexOf(item);

        if (startIndex != -1 && endIndex != -1)
        {
            int low = qMin(startIndex, endIndex);
            int high = qMax(startIndex, endIndex);

            // Select all items in the range
            for (int i = low; i <= high; i++)
            {
                if (i < allSignalItems.size())
                {
                    QTreeWidgetItem *rangeItem = allSignalItems[i];
                    VCDSignal rangeSignal = rangeItem->data(0, Qt::UserRole).value<VCDSignal>();
                    selectedSignals.insert(rangeSignal.fullName); // CHANGE: use fullName
                    rangeItem->setCheckState(0, Qt::Checked);
                }
            }
        }
    }
    else if (modifiers & Qt::ControlModifier)
    {
        // Ctrl+click: toggle selection of current item
        if (selectedSignals.contains(signal.fullName)) // CHANGE: use fullName
        {
            selectedSignals.remove(signal.fullName); // CHANGE: use fullName
            item->setCheckState(0, Qt::Unchecked);
        }
        else
        {
            selectedSignals.insert(signal.fullName); // CHANGE: use fullName
            item->setCheckState(0, Qt::Checked);
        }
        lastSelectedItem = item;
    }
    else
    {
        // Regular click: single selection (clear others and select this one)
        // First, clear all selections
        QTreeWidgetItemIterator clearIt(signalTree);
        while (*clearIt)
        {
            QVariant clearData = (*clearIt)->data(0, Qt::UserRole);
            if (clearData.canConvert<VCDSignal>())
            {
                VCDSignal clearSignal = clearData.value<VCDSignal>();
                selectedSignals.remove(clearSignal.fullName); // CHANGE: use fullName
                (*clearIt)->setCheckState(0, Qt::Unchecked);
            }
            ++clearIt;
        }

        // Then select the clicked item
        selectedSignals.insert(signal.fullName); // CHANGE: use fullName
        item->setCheckState(0, Qt::Checked);
        lastSelectedItem = item;
    }

    // Unblock signals
    signalTree->blockSignals(false);

    // Update status
    statusLabel->setText(QString("%1 signal(s) selected").arg(selectedSignals.size()));
}


void SignalSelectionDialog::setAvailableSignals(const QVector<VCDSignal> &allSignals, const QList<VCDSignal> &visibleSignals)
{
    this->allSignals = allSignals;
    selectedSignals.clear();
    scopeSignals.clear();
    childScopes.clear();
    populatedScopes.clear();
    lastSelectedItem = nullptr;

    signalTree->clear();

    // Create a set of visible signal fullNames
    visibleSignalIdentifiers.clear();
    for (const auto &signal : visibleSignals) {
        visibleSignalIdentifiers.insert(signal.fullName);
    }

    statusLabel->setText(QString("Ready to load %1 signals").arg(allSignals.size()));
}

void SignalSelectionDialog::processNextChunk()
{
    if (!isLoadingInProgress || currentLoadIndex >= allSignals.size()) {
        // Loading complete
        onLoadFinished();
        return;
    }

    const int CHUNK_SIZE = 500; // Process 500 signals per chunk
    int endIndex = qMin(currentLoadIndex + CHUNK_SIZE, allSignals.size());

    for (int i = currentLoadIndex; i < endIndex; i++) {
        const auto &signal = allSignals[i];

        // Skip signals that are already visible
        if (visibleSignalIdentifiers.contains(signal.fullName)) {
            continue;
        }

        QString scopePath = signal.scope;

        // Add signal to its scope
        scopeSignals[scopePath].append(signal);

        // Build parent-child scope relationships
        if (!scopePath.isEmpty()) {
            QStringList scopeParts = scopePath.split('.');
            QString currentPath;

            for (int j = 0; j < scopeParts.size(); j++) {
                if (!currentPath.isEmpty())
                    currentPath += ".";
                currentPath += scopeParts[j];

                if (j < scopeParts.size() - 1) {
                    QString parentPath = currentPath;
                    QString childName = scopeParts[j + 1];
                    QString childPath = parentPath + "." + childName;

                    if (!childScopes[parentPath].contains(childPath)) {
                        childScopes[parentPath].append(childPath);
                    }
                }
            }
        }
    }

    currentLoadIndex = endIndex;

    // Update progress
    int progress = (currentLoadIndex * 100) / allSignals.size();
    progressBar->setValue(progress);
    statusLabel->setText(QString("Building scope structure... %1% (%2/%3 signals)").arg(progress).arg(currentLoadIndex).arg(allSignals.size()));

    // Force UI update
    QApplication::processEvents();

    // Process next chunk after a brief delay to keep UI responsive
    QTimer::singleShot(1, this, &SignalSelectionDialog::processNextChunk);
}

void SignalSelectionDialog::startInitialLoad()
{
    if (isLoadingInProgress || isInitialLoadComplete) {
        return;
    }

    isLoadingInProgress = true;
    currentLoadIndex = 0;
    totalSignalsToProcess = allSignals.size();
    
    statusLabel->setText("Building scope structure...");
    progressBar->setVisible(true);
    progressBar->setRange(0, 100);
    progressBar->setValue(0);

    // Process in chunks using a timer to avoid freezing
    QTimer::singleShot(0, this, &SignalSelectionDialog::processNextChunk);
}

void SignalSelectionDialog::onLoadProgress(int percentage)
{
    if (!isLoadingInProgress) return;
    
    progressBar->setValue(percentage);
    statusLabel->setText(QString("Building scope structure... %1%").arg(percentage));
}

void SignalSelectionDialog::onLoadFinished()
{
    isLoadingInProgress = false;
    isInitialLoadComplete = true;

    progressBar->setVisible(false);
    
    // Apply the current filter instead of just populating top-level scopes
    applySignalFilter();
    
    statusLabel->setText(QString("Ready - %1 signals in %2 scopes")
                         .arg(allSignals.size())
                         .arg(scopeSignals.size()));
}

void SignalSelectionDialog::populateTopLevelScopesLazy()
{
    signalTree->setUpdatesEnabled(false);
    
    // Add global signals (signals with no scope)
    if (scopeSignals.contains("") && !scopeSignals[""].isEmpty()) {
        QTreeWidgetItem *globalItem = new QTreeWidgetItem();
        globalItem->setText(0, "Global Signals");
        globalItem->setData(0, Qt::UserRole, "");
        globalItem->setFlags(globalItem->flags() | Qt::ItemIsUserCheckable);
        signalTree->addTopLevelItem(globalItem);

        // Add placeholder for lazy loading
        QTreeWidgetItem *placeholder = new QTreeWidgetItem();
        placeholder->setText(0, "Loading...");
        placeholder->setData(0, Qt::UserRole, "PLACEHOLDER");
        globalItem->addChild(placeholder);

        populatedScopes.insert("");
        updateScopeCheckState(globalItem);
    }

    // Find top-level scopes
    QSet<QString> topLevelScopes;
    for (const QString &scope : scopeSignals.keys()) {
        if (!scope.isEmpty() && !scopeSignals[scope].isEmpty()) {
            bool isTopLevel = true;
            for (const QString &potentialParent : scopeSignals.keys()) {
                if (scope.startsWith(potentialParent + ".") && scope != potentialParent) {
                    isTopLevel = false;
                    break;
                }
            }
            if (isTopLevel) {
                topLevelScopes.insert(scope);
            }
        }
    }

    // Create tree items for top-level scopes
    for (const QString &scope : topLevelScopes) {
        QString displayName = scope;
        QStringList parts = scope.split('.');
        if (!parts.isEmpty()) {
            displayName = parts.last();
        }

        QTreeWidgetItem *scopeItem = new QTreeWidgetItem();
        scopeItem->setText(0, displayName);
        scopeItem->setToolTip(0, scope);
        scopeItem->setData(0, Qt::UserRole, scope);
        scopeItem->setFlags(scopeItem->flags() | Qt::ItemIsUserCheckable);

        // Add placeholder for lazy loading
        QTreeWidgetItem *placeholder = new QTreeWidgetItem();
        placeholder->setText(0, "Loading...");
        placeholder->setData(0, Qt::UserRole, "PLACEHOLDER");
        scopeItem->addChild(placeholder);

        signalTree->addTopLevelItem(scopeItem);
        populatedScopes.insert(scope);
        updateScopeCheckState(scopeItem);
    }

    signalTree->setUpdatesEnabled(true);
}

void SignalSelectionDialog::populateTopLevelScopes()
{
    signalTree->setUpdatesEnabled(false);
    signalTree->clear();
    
    // Add global signals (signals with no scope)
    if (scopeSignals.contains("") && !scopeSignals[""].isEmpty()) {
        QTreeWidgetItem *globalItem = new QTreeWidgetItem();
        globalItem->setText(0, "Global Signals");
        globalItem->setData(0, Qt::UserRole, "");
        globalItem->setFlags(globalItem->flags() | Qt::ItemIsUserCheckable);
        signalTree->addTopLevelItem(globalItem);

        // Add placeholder for lazy loading
        QTreeWidgetItem *placeholder = new QTreeWidgetItem();
        placeholder->setText(0, "Loading...");
        placeholder->setData(0, Qt::UserRole, "PLACEHOLDER");
        globalItem->addChild(placeholder);

        populatedScopes.insert("");
        updateScopeCheckState(globalItem);
        
        // NEW: Expand the global signals item
        globalItem->setExpanded(true);
    }

    // Find top-level scopes
    QSet<QString> topLevelScopes;
    for (const QString &scope : scopeSignals.keys()) {
        if (!scope.isEmpty() && !scopeSignals[scope].isEmpty()) {
            bool isTopLevel = true;
            for (const QString &potentialParent : scopeSignals.keys()) {
                if (scope.startsWith(potentialParent + ".") && scope != potentialParent) {
                    isTopLevel = false;
                    break;
                }
            }
            if (isTopLevel) {
                topLevelScopes.insert(scope);
            }
        }
    }

    // Create tree items for top-level scopes
    for (const QString &scope : topLevelScopes) {
        QString displayName = scope;
        QStringList parts = scope.split('.');
        if (!parts.isEmpty()) {
            displayName = parts.last();
        }

        QTreeWidgetItem *scopeItem = new QTreeWidgetItem();
        scopeItem->setText(0, displayName);
        scopeItem->setToolTip(0, scope);
        scopeItem->setData(0, Qt::UserRole, scope);
        scopeItem->setFlags(scopeItem->flags() | Qt::ItemIsUserCheckable);

        // Add placeholder for lazy loading
        QTreeWidgetItem *placeholder = new QTreeWidgetItem();
        placeholder->setText(0, "Loading...");
        placeholder->setData(0, Qt::UserRole, "PLACEHOLDER");
        scopeItem->addChild(placeholder);

        signalTree->addTopLevelItem(scopeItem);
        populatedScopes.insert(scope);
        updateScopeCheckState(scopeItem);
        
        // NEW: Expand all top-level scope items
        scopeItem->setExpanded(true);
    }

    signalTree->setUpdatesEnabled(true);
}

void SignalSelectionDialog::onItemExpanded(QTreeWidgetItem *item)
{
    QString scopePath = item->data(0, Qt::UserRole).toString();
    if (scopePath != "PLACEHOLDER") {
        populateScopeChildren(scopePath, item);
    }
}



QList<VCDSignal> SignalSelectionDialog::getSelectedSignals() const
{
    QList<VCDSignal> result;

    for (const QString &fullName : selectedSignals) // CHANGE: use fullName
    {
        // Find the signal in allSignals
        for (const VCDSignal &signal : allSignals)
        {
            if (signal.fullName == fullName) // CHANGE: use fullName
            {
                result.append(signal);
                break;
            }
        }
    }

    return result;
}

void SignalSelectionDialog::selectAll()
{
    signalTree->blockSignals(true);

    if (currentFilter.isEmpty()) {
        // Original behavior when no search filter
        for (const auto &signal : allSignals)
        {
            if (!visibleSignalIdentifiers.contains(signal.fullName))
            {
                selectedSignals.insert(signal.fullName);
            }
        }

        // Update all tree items
        QTreeWidgetItemIterator it(signalTree);
        while (*it)
        {
            QTreeWidgetItem *item = *it;
            QVariant data = item->data(0, Qt::UserRole);

            if (data.canConvert<VCDSignal>())
            {
                VCDSignal signal = data.value<VCDSignal>();
                if (!visibleSignalIdentifiers.contains(signal.fullName))
                {
                    item->setCheckState(0, Qt::Checked);
                }
            }
            else if (data.toString() != "PLACEHOLDER")
            {
                // Scope item - check it and update its state
                item->setCheckState(0, Qt::Checked);
                updateScopeCheckState(item);
            }
            ++it;
        }
    } else {
        // NEW: When search is active, only select currently displayed signals
        QTreeWidgetItemIterator it(signalTree);
        while (*it)
        {
            QTreeWidgetItem *item = *it;
            QVariant data = item->data(0, Qt::UserRole);

            if (data.canConvert<VCDSignal>())
            {
                VCDSignal signal = data.value<VCDSignal>();
                selectedSignals.insert(signal.fullName);
                item->setCheckState(0, Qt::Checked);
            }
            ++it;
        }

        // Update scope check states for search results
        for (int i = 0; i < signalTree->topLevelItemCount(); ++i)
        {
            QTreeWidgetItem *topLevelItem = signalTree->topLevelItem(i);
            updateScopeCheckState(topLevelItem);
        }
    }

    signalTree->blockSignals(false);
    statusLabel->setText(QString("%1 signal(s) selected").arg(selectedSignals.size()));
}


void SignalSelectionDialog::deselectAll()
{
    signalTree->blockSignals(true);

    if (currentFilter.isEmpty()) {
        // Original behavior when no search filter
        selectedSignals.clear();
        QTreeWidgetItemIterator it(signalTree);
        while (*it)
        {
            QTreeWidgetItem *item = *it;
            QVariant data = item->data(0, Qt::UserRole);

            if (data.canConvert<VCDSignal>())
            {
                item->setCheckState(0, Qt::Unchecked);
            }
            else if (data.toString() != "PLACEHOLDER")
            {
                // Scope item - uncheck it
                item->setCheckState(0, Qt::Unchecked);
            }
            ++it;
        }
    } else {
        // NEW: When search is active, only deselect currently displayed signals
        QTreeWidgetItemIterator it(signalTree);
        while (*it)
        {
            QTreeWidgetItem *item = *it;
            QVariant data = item->data(0, Qt::UserRole);

            if (data.canConvert<VCDSignal>())
            {
                VCDSignal signal = data.value<VCDSignal>();
                selectedSignals.remove(signal.fullName);
                item->setCheckState(0, Qt::Unchecked);
            }
            ++it;
        }

        // Update scope check states for search results
        for (int i = 0; i < signalTree->topLevelItemCount(); ++i)
        {
            QTreeWidgetItem *topLevelItem = signalTree->topLevelItem(i);
            updateScopeCheckState(topLevelItem);
        }
    }

    lastSelectedItem = nullptr;
    signalTree->blockSignals(false);
    
    if (currentFilter.isEmpty()) {
        statusLabel->setText("All signals deselected");
    } else {
        statusLabel->setText("All displayed signals deselected");
    }
}

void SignalSelectionDialog::displaySearchResults(const QString &text, int matches, const QMap<QString, QVector<VCDSignal>> &matchingSignalsByScope)
{
    if (text != currentFilter) {
        return; // Stale results
    }

    signalTree->setUpdatesEnabled(false);
    signalTree->blockSignals(true);
    signalTree->clear();

    if (!matchingSignalsByScope.isEmpty()) {
        for (auto it = matchingSignalsByScope.begin(); it != matchingSignalsByScope.end(); ++it) {
            QString scopePath = it.key();
            QVector<VCDSignal> signalsInScope = it.value();

            QTreeWidgetItem *scopeItem;
            if (scopePath.isEmpty()) {
                scopeItem = new QTreeWidgetItem(signalTree);
                scopeItem->setText(0, "Global Signals");
            } else {
                scopeItem = new QTreeWidgetItem(signalTree);
                scopeItem->setText(0, scopePath);
            }

            scopeItem->setFlags(scopeItem->flags() | Qt::ItemIsUserCheckable);
            scopeItem->setData(0, Qt::UserRole, scopePath);
            updateScopeCheckState(scopeItem);

            for (const VCDSignal &signal : signalsInScope) {
                QTreeWidgetItem *signalItem = new QTreeWidgetItem(scopeItem);
                signalItem->setText(0, signal.name);
                signalItem->setText(1, QString::number(signal.width));
                signalItem->setText(2, signal.type);
                signalItem->setText(3, signal.identifier);
                signalItem->setData(0, Qt::UserRole, QVariant::fromValue(signal));
                signalItem->setFlags(signalItem->flags() | Qt::ItemIsUserCheckable);

                if (selectedSignals.contains(signal.fullName)) {
                    signalItem->setCheckState(0, Qt::Checked);
                } else {
                    signalItem->setCheckState(0, Qt::Unchecked);
                }
            }
            scopeItem->setExpanded(true);
        }
    } else {
        QTreeWidgetItem *noResultsItem = new QTreeWidgetItem(signalTree);
        noResultsItem->setText(0, "No signals found matching: " + text);
        noResultsItem->setFlags(noResultsItem->flags() & ~Qt::ItemIsSelectable);
    }

    signalTree->blockSignals(false);
    signalTree->setUpdatesEnabled(true);

    // Updated status message to indicate search mode
    if (matches > 0) {
        statusLabel->setText(QString("Found %1 signals matching '%2' - Use Select All/Deselect All for displayed signals only")
                             .arg(matches).arg(text));
    } else {
        statusLabel->setText(QString("No signals found matching '%1'").arg(text));
    }
}

void SignalSelectionDialog::performSearch(const QString &text)
{
    isSearchInProgress = true;
    
    QString searchLower = text.toLower();
    QMap<QString, QVector<VCDSignal>> matchingSignalsByScope;
    int matches = 0;
    int processed = 0;

    const int CHUNK_SIZE = 500; // Process 500 signals at a time

    for (const auto &signal : allSignals) {
        if (visibleSignalIdentifiers.contains(signal.fullName)) {
            processed++;
            continue;
        }

        QString signalPath = (signal.scope.isEmpty() ? signal.name : signal.scope + "." + signal.name).toLower();
        if (signalPath.contains(searchLower)) {
            matchingSignalsByScope[signal.scope].append(signal);
            matches++;
        }

        processed++;
        
        // Process events every CHUNK_SIZE to keep UI responsive
        if (processed % CHUNK_SIZE == 0) {
            QApplication::processEvents(QEventLoop::ExcludeUserInputEvents);
            
            // Check if search was cancelled (new text entered)
            if (text != currentFilter) {
                isSearchInProgress = false;
                return;
            }
        }
    }

    // Display results
    displaySearchResults(text, matches, matchingSignalsByScope);
    isSearchInProgress = false;
    
    // Check if there's a pending search
    if (!pendingSearchText.isNull() && pendingSearchText != text) {
        QTimer::singleShot(0, this, [this]() {
            onSearchTextChanged(pendingSearchText);
        });
    }
}

void SignalSelectionDialog::onSearchTextChanged(const QString &text)
{
    if (isSearchInProgress) {
        // If a search is already running, we'll let it finish
        // The new search will be handled when the current one completes
        pendingSearchText = text;
        return;
    }

    currentFilter = text;

    // For immediate feedback on empty search
    if (text.isEmpty()) {
        applySignalFilter();  // Use the new filter function
        return;
    }

    // Show searching status
    statusLabel->setText("Searching...");
    
    QApplication::processEvents(); // Update UI

    // Perform search in main thread but with chunked processing
    performSearch(text);
}

SignalSelectionDialog::~SignalSelectionDialog()
{
    if (searchTimer && searchTimer->isActive()) {
        searchTimer->stop();
    }
    if (loadWatcher && loadWatcher->isRunning()) {
        loadWatcher->cancel();
        loadWatcher->waitForFinished();
    }
}

void SignalSelectionDialog::closeEvent(QCloseEvent *event)
{
    if (searchTimer && searchTimer->isActive()) {
        searchTimer->stop();
    }
    if (loadWatcher && loadWatcher->isRunning()) {
        loadWatcher->cancel();
        loadWatcher->waitForFinished();
    }
    QDialog::closeEvent(event);
}

void SignalSelectionDialog::showEvent(QShowEvent *event)
{
    QDialog::showEvent(event);
    
    // Start initial loading when dialog is shown
    if (!isInitialLoadComplete && !isLoadingInProgress && !allSignals.isEmpty()) {
        startInitialLoad();
    }
}

void SignalSelectionDialog::onSearchTimerTimeout()
{
    if (!pendingSearchText.isNull()) {
        onSearchTextChanged(pendingSearchText);
    }
}

void SignalSelectionDialog::onScopeItemChanged(QTreeWidgetItem *item, int column)
{
    if (column != 0) return;
    if (!item) return;

    QVariant data = item->data(0, Qt::UserRole);
    QString scopePath = data.toString();

    // Only process scope items (not signal items and not placeholders)
    if (scopePath == "PLACEHOLDER" || data.canConvert<VCDSignal>())
        return;

    // Block signals to prevent recursive calls
    signalTree->blockSignals(true);

    bool isChecked = (item->checkState(0) == Qt::Checked);

    // Select/deselect all signals in this scope and all sub-scopes
    setScopeSignalsSelection(scopePath, isChecked);

    // Update the visual check states in the tree for this scope and all children
    updateTreeWidgetCheckStates(scopePath, isChecked);

    // Update parent scopes' check states
    updateParentScopeCheckState(item);

    signalTree->blockSignals(false);

    // Update status
    statusLabel->setText(QString("%1 signal(s) selected").arg(selectedSignals.size()));
}



void SignalSelectionDialog::updateTreeWidgetCheckStates(const QString &scopePath, bool selected)
{
    // Recursively update all items in the tree for this scope and its children
    QTreeWidgetItemIterator it(signalTree);
    while (*it)
    {
        QTreeWidgetItem *item = *it;
        QVariant data = item->data(0, Qt::UserRole);

        if (data.canConvert<VCDSignal>())
        {
            // Signal item - update if it belongs to this scope or sub-scope
            VCDSignal signal = data.value<VCDSignal>();
            if (signal.scope == scopePath || signal.scope.startsWith(scopePath + "."))
            {
                item->setCheckState(0, selected ? Qt::Checked : Qt::Unchecked);
            }
        }
        else
        {
            // Scope item - update if it's this scope or a sub-scope
            QString itemScope = data.toString();
            if ((itemScope == scopePath || itemScope.startsWith(scopePath + ".")) && itemScope != "PLACEHOLDER")
            {
                item->setCheckState(0, selected ? Qt::Checked : Qt::Unchecked);
            }
        }
        ++it;
    }
}

void SignalSelectionDialog::setScopeSignalsSelection(const QString &scopePath, bool selected)
{
    // Process current scope signals
    if (scopeSignals.contains(scopePath))
    {
        for (const VCDSignal &signal : scopeSignals[scopePath])
        {
            if (selected)
            {
                selectedSignals.insert(signal.fullName); // CHANGE: use fullName
            }
            else
            {
                selectedSignals.remove(signal.fullName); // CHANGE: use fullName
            }
        }
    }

    // Process child scopes recursively
    if (childScopes.contains(scopePath))
    {
        for (const QString &childScope : childScopes[scopePath])
        {
            setScopeSignalsSelection(childScope, selected);
        }
    }
}


void SignalSelectionDialog::updateScopeCheckState(QTreeWidgetItem *scopeItem)
{
    if (!scopeItem)
        return;

    QString scopePath = scopeItem->data(0, Qt::UserRole).toString();
    if (scopePath == "PLACEHOLDER")
        return;

    // Count ALL selected signals in this scope and ALL sub-scopes
    int totalSignals = 0;
    int selectedSignalsCount = 0;

    // Count signals in current scope
    if (scopeSignals.contains(scopePath))
    {
        totalSignals += scopeSignals[scopePath].size();
        for (const VCDSignal &signal : scopeSignals[scopePath])
        {
            if (selectedSignals.contains(signal.fullName)) // CHANGE: use fullName
            {
                selectedSignalsCount++;
            }
        }
    }

    // Count signals in all child scopes recursively using QList
    QSet<QString> processedScopes;
    QList<QString> scopesToProcess;
    
    if (childScopes.contains(scopePath))
    {
        for (const QString &childScope : childScopes[scopePath])
        {
            scopesToProcess.append(childScope);
        }
    }

    while (!scopesToProcess.isEmpty())
    {
        QString currentScope = scopesToProcess.takeFirst();
        if (processedScopes.contains(currentScope))
            continue;
            
        processedScopes.insert(currentScope);

        // Count signals in this child scope
        if (scopeSignals.contains(currentScope))
        {
            totalSignals += scopeSignals[currentScope].size();
            for (const VCDSignal &signal : scopeSignals[currentScope])
            {
                if (selectedSignals.contains(signal.fullName)) // CHANGE: use fullName
                {
                    selectedSignalsCount++;
                }
            }
        }

        // Add child scopes of this scope to the list
        if (childScopes.contains(currentScope))
        {
            for (const QString &childScope : childScopes[currentScope])
            {
                if (!processedScopes.contains(childScope))
                {
                    scopesToProcess.append(childScope);
                }
            }
        }
    }

    // Set check state based on selection
    if (totalSignals == 0)
    {
        scopeItem->setCheckState(0, Qt::Unchecked);
    }
    else if (selectedSignalsCount == 0)
    {
        scopeItem->setCheckState(0, Qt::Unchecked);
    }
    else if (selectedSignalsCount == totalSignals)
    {
        scopeItem->setCheckState(0, Qt::Checked);
    }
    else
    {
        scopeItem->setCheckState(0, Qt::PartiallyChecked);
    }
}

void SignalSelectionDialog::updateParentScopeCheckState(QTreeWidgetItem *childItem)
{
    if (!childItem) return;
    
    QTreeWidgetItem *parent = childItem->parent();
    if (!parent) return;

    // Update the parent's check state
    updateScopeCheckState(parent);

    // Recursively update grandparents
    updateParentScopeCheckState(parent);
}

void SignalSelectionDialog::populateScopeChildren(const QString &scopePath, QTreeWidgetItem *parentItem)
{
    if (!parentItem || populatedScopes.contains(scopePath + "_POPULATED")) {
        return;
    }

    // Remove placeholder
    while (parentItem->childCount() > 0) {
        QTreeWidgetItem *child = parentItem->child(0);
        if (child->data(0, Qt::UserRole).toString() == "PLACEHOLDER") {
            delete child;
            break;
        }
    }

    // Make parent item checkable if it's a scope
    parentItem->setFlags(parentItem->flags() | Qt::ItemIsUserCheckable);

    // Update initial check state for scope
    updateScopeCheckState(parentItem);

    // Add child scopes
    if (childScopes.contains(scopePath)) {
        for (const QString &childScopePath : childScopes[scopePath]) {
            QString displayName = childScopePath;
            // Extract just the last part for display
            QStringList parts = childScopePath.split('.');
            if (!parts.isEmpty()) {
                displayName = parts.last();
            }

            QTreeWidgetItem *childScopeItem = new QTreeWidgetItem();
            childScopeItem->setText(0, displayName);
            childScopeItem->setToolTip(0, childScopePath); // Show full path
            childScopeItem->setData(0, Qt::UserRole, childScopePath);
            childScopeItem->setFlags(childScopeItem->flags() | Qt::ItemIsUserCheckable);

            // Set initial check state
            updateScopeCheckState(childScopeItem);

            // Add placeholder
            QTreeWidgetItem *placeholder = new QTreeWidgetItem();
            placeholder->setText(0, "Loading...");
            placeholder->setData(0, Qt::UserRole, "PLACEHOLDER");
            childScopeItem->addChild(placeholder);

            parentItem->addChild(childScopeItem);
        }
    }

    // Add signals in this scope
    if (scopeSignals.contains(scopePath)) {
        for (const VCDSignal &signal : scopeSignals[scopePath]) {
            // Apply filter if active
            if (!currentFilter.isEmpty()) {
                QString signalPath = (signal.scope.isEmpty() ? signal.name : signal.scope + "." + signal.name).toLower();
                if (!signalPath.contains(currentFilter.toLower())) {
                    continue;
                }
            }

            QTreeWidgetItem *signalItem = new QTreeWidgetItem();
            signalItem->setText(0, signal.name);
            signalItem->setText(1, QString::number(signal.width));
            signalItem->setText(2, signal.type);
            signalItem->setText(3, signal.identifier);
            signalItem->setData(0, Qt::UserRole, QVariant::fromValue(signal));
            signalItem->setFlags(signalItem->flags() | Qt::ItemIsUserCheckable);

            if (selectedSignals.contains(signal.fullName)) {
                signalItem->setCheckState(0, Qt::Checked);
            } else {
                signalItem->setCheckState(0, Qt::Unchecked);
            }

            parentItem->addChild(signalItem);
        }
    }

    populatedScopes.insert(scopePath + "_POPULATED");
}

// NEW: Filter button implementations
void SignalSelectionDialog::onFilterInputPorts()
{
    currentTypeFilter = "input";
    filterInputButton->setChecked(true);
    filterOutputButton->setChecked(false);
    filterInoutButton->setChecked(false);
    filterNetButton->setChecked(false);
    filterRegButton->setChecked(false);
    filterAllButton->setChecked(false);
    applySignalFilter();
}

void SignalSelectionDialog::onFilterOutputPorts()
{
    currentTypeFilter = "output";
    filterInputButton->setChecked(false);
    filterOutputButton->setChecked(true);
    filterInoutButton->setChecked(false);
    filterNetButton->setChecked(false);
    filterRegButton->setChecked(false);
    filterAllButton->setChecked(false);
    applySignalFilter();
}

void SignalSelectionDialog::onFilterInoutPorts()
{
    currentTypeFilter = "inout";
    filterInputButton->setChecked(false);
    filterOutputButton->setChecked(false);
    filterInoutButton->setChecked(true);
    filterNetButton->setChecked(false);
    filterRegButton->setChecked(false);
    filterAllButton->setChecked(false);
    applySignalFilter();
}

void SignalSelectionDialog::onFilterNetSignals()
{
    currentTypeFilter = "wire";
    filterInputButton->setChecked(false);
    filterOutputButton->setChecked(false);
    filterInoutButton->setChecked(false);
    filterNetButton->setChecked(true);
    filterRegButton->setChecked(false);
    filterAllButton->setChecked(false);
    applySignalFilter();
}

void SignalSelectionDialog::onFilterRegisters()
{
    currentTypeFilter = "reg";
    filterInputButton->setChecked(false);
    filterOutputButton->setChecked(false);
    filterInoutButton->setChecked(false);
    filterNetButton->setChecked(false);
    filterRegButton->setChecked(true);
    filterAllButton->setChecked(false);
    applySignalFilter();
}

void SignalSelectionDialog::onFilterAll()
{
    currentTypeFilter = "all";
    filterInputButton->setChecked(false);
    filterOutputButton->setChecked(false);
    filterInoutButton->setChecked(false);
    filterNetButton->setChecked(false);
    filterRegButton->setChecked(false);
    filterAllButton->setChecked(true);
    applySignalFilter();
}

void SignalSelectionDialog::applySignalFilter()
{
    if (!isInitialLoadComplete) {
        return; // Wait until initial load is complete
    }

    signalTree->setUpdatesEnabled(false);
    signalTree->blockSignals(true);
    signalTree->clear();

    // Build a map of signals by scope, filtered by type
    QMap<QString, QVector<VCDSignal>> filteredSignalsByScope;

    for (const auto &signal : allSignals) {
        // Skip signals that are already visible
        if (visibleSignalIdentifiers.contains(signal.fullName)) {
            continue;
        }

        // Apply type filter
        if (currentTypeFilter != "all" && signal.type.toLower() != currentTypeFilter) {
            continue;
        }

        // Apply search filter if active
        if (!currentFilter.isEmpty()) {
            QString signalPath = (signal.scope.isEmpty() ? signal.name : signal.scope + "." + signal.name).toLower();
            if (!signalPath.contains(currentFilter.toLower())) {
                continue;
            }
        }

        filteredSignalsByScope[signal.scope].append(signal);
    }

    // Populate the tree with filtered signals
    if (!filteredSignalsByScope.isEmpty()) {
        for (auto it = filteredSignalsByScope.begin(); it != filteredSignalsByScope.end(); ++it) {
            QString scopePath = it.key();
            QVector<VCDSignal> signalsInScope = it.value();

            QTreeWidgetItem *scopeItem;
            if (scopePath.isEmpty()) {
                scopeItem = new QTreeWidgetItem(signalTree);
                scopeItem->setText(0, "Global Signals");
            } else {
                scopeItem = new QTreeWidgetItem(signalTree);
                scopeItem->setText(0, scopePath);
            }

            scopeItem->setFlags(scopeItem->flags() | Qt::ItemIsUserCheckable);
            scopeItem->setData(0, Qt::UserRole, scopePath);
            updateScopeCheckState(scopeItem);

            for (const VCDSignal &signal : signalsInScope) {
                QTreeWidgetItem *signalItem = new QTreeWidgetItem(scopeItem);
                signalItem->setText(0, signal.name);
                signalItem->setText(1, QString::number(signal.width));
                signalItem->setText(2, signal.type);
                signalItem->setText(3, signal.identifier);
                signalItem->setData(0, Qt::UserRole, QVariant::fromValue(signal));
                signalItem->setFlags(signalItem->flags() | Qt::ItemIsUserCheckable);

                if (selectedSignals.contains(signal.fullName)) {
                    signalItem->setCheckState(0, Qt::Checked);
                } else {
                    signalItem->setCheckState(0, Qt::Unchecked);
                }
            }
            scopeItem->setExpanded(true);
        }
    } else {
        QTreeWidgetItem *noResultsItem = new QTreeWidgetItem(signalTree);
        noResultsItem->setText(0, QString("No %1 signals found").arg(currentTypeFilter == "all" ? "" : currentTypeFilter + " "));
        noResultsItem->setFlags(noResultsItem->flags() & ~Qt::ItemIsSelectable);
    }

    signalTree->blockSignals(false);
    signalTree->setUpdatesEnabled(true);

    // Update status
    int totalFilteredSignals = 0;
    for (const auto &signalList : filteredSignalsByScope) {  // CHANGED: renamed from 'signals' to 'signalList'
        totalFilteredSignals += signalList.size();
    }
    
    if (currentTypeFilter == "all") {
        statusLabel->setText(QString("Showing %1 signals").arg(totalFilteredSignals));
    } else {
        statusLabel->setText(QString("Showing %1 %2 signals").arg(totalFilteredSignals).arg(currentTypeFilter));
    }
}// file: main.cpp
#include "mainwindow.h"
#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    // Set application properties
    app.setApplicationName("VCD Wave Viewer");
    app.setApplicationVersion("1.0");
    app.setOrganizationName("VCDViewer");

    MainWindow window;
    window.show();

    return app.exec();
}
#include "mainwindow.h"
#include "SignalSelectionDialog.h"
#include <QTreeWidgetItemIterator>
#include <QFileInfo>
#include <QMessageBox>
#include <QSplitter>
#include <QToolBar>
#include <QStatusBar>
#include <QFileDialog>
#include <QLabel>
#include <QApplication>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QWidget>
#include <QDir>
#include <QToolButton>
#include <QKeyEvent>
#include <QtConcurrent>
#include <QMenuBar>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), vcdParser(new VCDParser(this))
{
    qRegisterMetaType<VCDSignal>("VCDSignal");
    setWindowTitle("VCD Wave Viewer");
    setMinimumSize(1200, 800);

    createActions();
    setupUI();
    createMenuBar();
    createMainToolbar();
    setupNavigationControls();
    createStatusBar();

    // Don't load default VCD file - let user choose
    statusLabel->setText("Use File → Open to load a VCD file");
}

MainWindow::~MainWindow()
{
}

void MainWindow::keyPressEvent(QKeyEvent *event)
{
    if (event->key() == Qt::Key_Delete)
    {
        // Let the waveform widget handle deletion if it has focus
        if (waveformWidget->hasFocus() && !waveformWidget->getSelectedItemIndices().isEmpty())
        {
            waveformWidget->removeSelectedSignals();
            event->accept();
        }
        else
        {
            // Fall back to the main window's delete handling
            removeSelectedSignals();
            event->accept();
        }
    }
    else if (event->key() == Qt::Key_A && event->modifiers() & Qt::ControlModifier)
    {
        waveformWidget->selectAllSignals();
        removeSignalsButton->setEnabled(true);
        event->accept();
    }
    else
    {
        QMainWindow::keyPressEvent(event);
    }
}

void MainWindow::createActions()
{
    openAction = new QAction("Open", this);
    openAction->setShortcut(QKeySequence::Open);
    connect(openAction, &QAction::triggered, this, &MainWindow::openFile);

    zoomInAction = new QAction("Zoom In", this);
    zoomInAction->setShortcut(QKeySequence::ZoomIn);
    connect(zoomInAction, &QAction::triggered, this, &MainWindow::zoomIn);

    resetColorsAction = new QAction("Reset Colors", this);
    connect(resetColorsAction, &QAction::triggered, this, &MainWindow::resetSignalColors);

    zoomOutAction = new QAction("Zoom Out", this);
    zoomOutAction->setShortcut(QKeySequence::ZoomOut);
    connect(zoomOutAction, &QAction::triggered, this, &MainWindow::zoomOut);

    zoomFitAction = new QAction("Zoom Fit", this);
    connect(zoomFitAction, &QAction::triggered, this, &MainWindow::zoomFit);

    aboutAction = new QAction("About", this);
    connect(aboutAction, &QAction::triggered, this, &MainWindow::about);

    // Wave menu actions
    defaultColorsAction = new QAction("Default Colors", this);
    connect(defaultColorsAction, &QAction::triggered, this, &MainWindow::resetSignalColors);

    // Bus format actions
    busHexAction = new QAction("Hexadecimal", this);
    busHexAction->setCheckable(true);
    busHexAction->setChecked(true);
    connect(busHexAction, &QAction::triggered, this, &MainWindow::setBusHexFormat);

    busBinaryAction = new QAction("Binary", this);
    busBinaryAction->setCheckable(true);
    connect(busBinaryAction, &QAction::triggered, this, &MainWindow::setBusBinaryFormat);

    busOctalAction = new QAction("Octal", this);
    busOctalAction->setCheckable(true);
    connect(busOctalAction, &QAction::triggered, this, &MainWindow::setBusOctalFormat);

    busDecimalAction = new QAction("Decimal", this);
    busDecimalAction->setCheckable(true);
    connect(busDecimalAction, &QAction::triggered, this, &MainWindow::setBusDecimalFormat);

    // Line thickness actions
    lineThinAction = new QAction("Thin (1px)", this);
    lineThinAction->setCheckable(true);
    connect(lineThinAction, &QAction::triggered, this, &MainWindow::setLineThicknessThin);

    lineMediumAction = new QAction("Medium (2px)", this);
    lineMediumAction->setCheckable(true);
    lineMediumAction->setChecked(true);
    connect(lineMediumAction, &QAction::triggered, this, &MainWindow::setLineThicknessMedium);

    // Signal height adjustment actions
    increaseHeightAction = new QAction("Increase Signal Height", this);
    increaseHeightAction->setShortcut(QKeySequence("Ctrl+Up"));
    connect(increaseHeightAction, &QAction::triggered, this, &MainWindow::increaseSignalHeight);

    decreaseHeightAction = new QAction("Decrease Signal Height", this);
    decreaseHeightAction->setShortcut(QKeySequence("Ctrl+Down"));
    connect(decreaseHeightAction, &QAction::triggered, this, &MainWindow::decreaseSignalHeight);
}

void MainWindow::createMenuBar()
{
    // Create proper menu bar
    QMenuBar *menuBar = this->menuBar();

    // File menu
    QMenu *fileMenu = menuBar->addMenu("File");
    fileMenu->addAction(openAction);

    // Edit menu (empty for now)
    QMenu *editMenu = menuBar->addMenu("Edit");

    // View menu
    QMenu *viewMenu = menuBar->addMenu("View");
    viewMenu->addAction(zoomInAction);
    viewMenu->addAction(zoomOutAction);
    viewMenu->addAction(zoomFitAction);

    // Workspace menu (empty for now)
    QMenu *workspaceMenu = menuBar->addMenu("Workspace");

    // Wave menu with submenus
    QMenu *waveMenu = menuBar->addMenu("Wave");
    waveMenu->addAction(increaseHeightAction);
    waveMenu->addAction(decreaseHeightAction);
    waveMenu->addSeparator();

    // Help menu
    QMenu *helpMenu = menuBar->addMenu("Help");
    helpMenu->addAction(aboutAction);

    // Signal colors submenu
    QMenu *signalColorsMenu = waveMenu->addMenu("Signal Colors");
    signalColorsMenu->addAction(defaultColorsAction);

    // Bus format submenu
    busFormatMenu = waveMenu->addMenu("Bus Format");
    busFormatMenu->addAction(busHexAction);
    busFormatMenu->addAction(busBinaryAction);
    busFormatMenu->addAction(busOctalAction);
    busFormatMenu->addAction(busDecimalAction);

    // Line thickness submenu
    lineThicknessMenu = waveMenu->addMenu("Line Thickness");
    lineThicknessMenu->addAction(lineThinAction);
    lineThicknessMenu->addAction(lineMediumAction);
}

void MainWindow::createMainToolbar()
{
    // Create main toolbar that appears below the menu bar
    mainToolBar = addToolBar("Main Toolbar");
    mainToolBar->setObjectName("MainToolbar");
    mainToolBar->setMovable(false);
    mainToolBar->setIconSize(QSize(16, 16));

    // Search field
    QLabel *searchLabel = new QLabel("Search:");
    searchField = new QLineEdit();
    searchField->setPlaceholderText("Search signals...");
    searchField->setMaximumWidth(200);
    searchField->setClearButtonEnabled(true);

    // Connect search field to waveform widget search functionality
    connect(searchField, &QLineEdit::textChanged, this, [this](const QString &text)
            { waveformWidget->searchSignals(text); });

    // Zoom controls
    QAction *zoomInToolbarAction = new QAction("🔍+", this);
    zoomInToolbarAction->setToolTip("Zoom In");
    connect(zoomInToolbarAction, &QAction::triggered, this, &MainWindow::zoomIn);

    QAction *zoomOutToolbarAction = new QAction("🔍-", this);
    zoomOutToolbarAction->setToolTip("Zoom Out");
    connect(zoomOutToolbarAction, &QAction::triggered, this, &MainWindow::zoomOut);

    QAction *zoomFitToolbarAction = new QAction("⤢ Fit", this);
    zoomFitToolbarAction->setToolTip("Zoom to Fit");
    connect(zoomFitToolbarAction, &QAction::triggered, this, &MainWindow::zoomFit);

    // Add widgets to toolbar
    mainToolBar->addWidget(searchLabel);
    mainToolBar->addWidget(searchField);
    mainToolBar->addSeparator();

    // Zoom controls
    mainToolBar->addAction(zoomInToolbarAction);
    mainToolBar->addAction(zoomOutToolbarAction);
    mainToolBar->addAction(zoomFitToolbarAction);

    // Add some spacing and stretch
    mainToolBar->addSeparator();
    QWidget *spacer = new QWidget();
    spacer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    mainToolBar->addWidget(spacer);
}

void MainWindow::increaseSignalHeight()
{
    waveformWidget->setSignalHeight(waveformWidget->getSignalHeight() + 2);
    statusLabel->setText(QString("Signal height increased to %1").arg(waveformWidget->getSignalHeight()));
}

void MainWindow::decreaseSignalHeight()
{
    waveformWidget->setSignalHeight(waveformWidget->getSignalHeight() - 2);
    statusLabel->setText(QString("Signal height decreased to %1").arg(waveformWidget->getSignalHeight()));
}

void MainWindow::resetSignalColors()
{
    waveformWidget->resetSignalColors();
}

void MainWindow::setLineThicknessThin()
{
    waveformWidget->setLineWidth(1);
    updateLineThicknessActions();
}

void MainWindow::setLineThicknessMedium()
{
    waveformWidget->setLineWidth(2);
    updateLineThicknessActions();
}

void MainWindow::updateLineThicknessActions()
{
    lineThinAction->setChecked(false);
    lineMediumAction->setChecked(false);

    int currentWidth = waveformWidget->getLineWidth();
    if (currentWidth == 1)
        lineThinAction->setChecked(true);
    else if (currentWidth == 2)
        lineMediumAction->setChecked(true);
}

void MainWindow::createStatusBar()
{
    statusLabel = new QLabel("Ready");
    statusBar()->addWidget(statusLabel);

    timeLabel = new QLabel("Time: 0");
    statusBar()->addPermanentWidget(timeLabel);
}

void MainWindow::setupUI()
{
    // Create central widget with waveform
    QWidget *centralWidget = new QWidget();
    QVBoxLayout *centralLayout = new QVBoxLayout(centralWidget);
    centralLayout->setContentsMargins(0, 0, 0, 0);
    centralLayout->setSpacing(0);

    // Create waveform widget
    waveformWidget = new WaveformWidget();
    connect(waveformWidget, &WaveformWidget::timeChanged,
            this, &MainWindow::updateTimeDisplay);
    connect(waveformWidget, &WaveformWidget::itemSelected, this, [this](int index)
            {
    // Enable/disable remove button based on selection
    removeSignalsButton->setEnabled(index >= 0);
    
    // Update navigation buttons based on new selection
    updateNavigationButtons(); });

    // === BOTTOM CONTROLS ===
    QWidget *bottomControls = new QWidget();
    QHBoxLayout *bottomLayout = new QHBoxLayout(bottomControls);
    bottomLayout->setContentsMargins(10, 5, 10, 5);

    addSignalsButton = new QPushButton("+ Add Signals");
    removeSignalsButton = new QPushButton("🗑️");

    addSignalsButton->setStyleSheet("QPushButton { padding: 8px; font-weight: bold; background-color: #4CAF50; color: white; }");
    removeSignalsButton->setStyleSheet("QPushButton { padding: 8px; font-weight: bold; background-color: #f44336; color: white; }");
    removeSignalsButton->setEnabled(false);
    removeSignalsButton->setToolTip("Remove selected signal (Delete)");

    connect(addSignalsButton, &QPushButton::clicked, this, &MainWindow::showAddSignalsDialog);
    connect(removeSignalsButton, &QPushButton::clicked, this, &MainWindow::removeSelectedSignals);

    bottomLayout->addWidget(addSignalsButton);
    bottomLayout->addWidget(removeSignalsButton);
    bottomLayout->addStretch();

    centralLayout->addWidget(waveformWidget, 1);
    centralLayout->addWidget(bottomControls);

    setCentralWidget(centralWidget);
}

// Update showAddSignalsDialog to be simpler
void MainWindow::showAddSignalsDialog()
{
    if (!vcdParser)
        return;

    int signalCount = vcdParser->getSignals().size();

    // Show immediate feedback for large files
    if (signalCount > 10000)
    {
        statusLabel->setText(QString("Loading signal selection dialog (%1 signals)...").arg(signalCount));
        QApplication::processEvents();

        // Use a simple message box for very large files
        if (signalCount > 50000)
        {
            QMessageBox::information(this, "Large File",
                                     QString("This file contains %1 signals.\n\n"
                                             "The signal selection will load in batches for better performance.\n"
                                             "Use the search filter to find specific signals quickly.")
                                         .arg(signalCount));
        }
    }

    SignalSelectionDialog dialog(this);

    // Get current signals
    QList<VCDSignal> currentSignals;
    for (int i = 0; i < waveformWidget->getItemCount(); i++)
    {
        const DisplayItem *item = waveformWidget->getItem(i);
        if (item && item->type == DisplayItem::Signal)
        {
            currentSignals.append(item->signal.signal);
        }
    }

    // Set signals and show dialog
    dialog.setAvailableSignals(vcdParser->getSignals(), currentSignals);

    if (dialog.exec() == QDialog::Accepted)
    {
        QList<VCDSignal> newSignalsToAdd = dialog.getSelectedSignals();
        if (!newSignalsToAdd.isEmpty())
        {
            statusLabel->setText(QString("Loading %1 signals...").arg(newSignalsToAdd.size()));
            QApplication::processEvents();

            // Add to current signals
            QList<VCDSignal> allSignalsToDisplay = currentSignals;
            allSignalsToDisplay.append(newSignalsToAdd);

            waveformWidget->setVisibleSignals(allSignalsToDisplay);

            // Update status
            int displayedCount = 0;
            for (int i = 0; i < waveformWidget->getItemCount(); i++)
            {
                const DisplayItem *item = waveformWidget->getItem(i);
                if (item && item->type == DisplayItem::Signal)
                {
                    displayedCount++;
                }
            }

            statusLabel->setText(QString("%1 signal(s) displayed").arg(displayedCount));
            removeSignalsButton->setEnabled(false);
        }
    }
}

void MainWindow::showRtlDirectoryDialog()
{
    QString rtlDir = QFileDialog::getExistingDirectory(this, "Select RTL Directory",
                                                      QFileInfo(currentVcdFilePath).dir().path());
    
    if (!rtlDir.isEmpty()) {
        // Reprocess VCD with the new RTL directory
        if (runVcdPortMapper(currentVcdFilePath, tempVcdFilePath, rtlDir)) {
            hasRtlDirectory = true;
            // Reload the VCD file
            loadVcdFile(currentVcdFilePath);
        }
    }
}

// Add cleanup in destructor or close event
void MainWindow::closeEvent(QCloseEvent *event)
{
    // Clean up temp VCD file
    if (QFile::exists(tempVcdFilePath)) {
        QFile::remove(tempVcdFilePath);
    }
    QMainWindow::closeEvent(event);
}

void MainWindow::removeSelectedSignals()
{
    // Check if there are any selected items in the waveform widget
    if (!waveformWidget->getSelectedItemIndices().isEmpty())
    {
        waveformWidget->removeSelectedSignals();
        removeSignalsButton->setEnabled(false);

        // Count only signals for display (not spaces)
        int signalCount = 0;
        for (int i = 0; i < waveformWidget->getItemCount(); i++)
        {
            const DisplayItem *item = waveformWidget->getItem(i);
            if (item && item->type == DisplayItem::Signal)
            {
                signalCount++;
            }
        }

        statusLabel->setText(QString("%1 signal(s) displayed").arg(signalCount));
    }
}

void MainWindow::loadDefaultVcdFile()
{
    QString defaultPath = "C:/Users/mismael/Desktop/OWV/test.vcd";

    if (QFile::exists(defaultPath))
    {
        loadVcdFile(defaultPath);
    }
    else
    {
        statusLabel->setText("Default VCD file not found. Use File → Open to load a VCD file.");
        qDebug() << "Default VCD file not found:" << defaultPath;
    }
}

// Update openFile to handle the new flow
void MainWindow::openFile()
{
    QString filename = QFileDialog::getOpenFileName(
        this, "Open VCD File", "", "VCD Files (*.vcd)");

    if (!filename.isEmpty())
    {
        loadVcdFile(filename);
    }
}

// Update loadVcdFile with the new verification logic
void MainWindow::loadVcdFile(const QString &filename)
{
    // Store the original VCD file path
    currentVcdFilePath = filename;
    
    // Check for RTL directory
    QString rtlDir = findRtlDirectory(filename);
    hasRtlDirectory = !rtlDir.isEmpty();
    
    // Create temp VCD file path
    QFileInfo fileInfo(filename);
    tempVcdFilePath = fileInfo.path() + "/" + fileInfo.completeBaseName() + "_temp.vcd";
    
    QString vcdToLoad = filename;
    bool rtlProcessingSuccess = false;
    
    if (hasRtlDirectory) {
        // Show RTL processing status
        statusLabel->setText("Checking RTL files for matching modules...");
        QApplication::processEvents();
        
        rtlProcessingSuccess = processVcdWithRtl(filename);
        
        if (rtlProcessingSuccess) {
            vcdToLoad = tempVcdFilePath;
            statusLabel->setText("VCD processed with RTL port information");
        } else {
            // Show warning about RTL mismatch
            QMessageBox msgBox(this);
            msgBox.setWindowTitle("RTL Module Mismatch");
            msgBox.setIcon(QMessageBox::Warning);
            msgBox.setText("RTL directory found, but no matching modules were detected.\n\n"
                          "The RTL files don't contain the modules found in the VCD file.\n\n"
                          "Would you like to specify a different RTL directory?");
            msgBox.setStandardButtons(QMessageBox::Yes | QMessageBox::No | QMessageBox::Ignore);
            msgBox.setDefaultButton(QMessageBox::Yes);
            
            int result = msgBox.exec();
            if (result == QMessageBox::Yes) {
                showRtlDirectoryDialog();
                return; // Restart the process
            } else if (result == QMessageBox::Ignore) {
                // Continue without RTL processing
                statusLabel->setText("Loading VCD without RTL information...");
            }
        }
    } else {
        // No RTL directory found - ask user
        QMessageBox msgBox(this);
        msgBox.setWindowTitle("RTL Information Not Available");
        msgBox.setIcon(QMessageBox::Information);
        msgBox.setText("No RTL directory found. Port directions (input/output/inout) will not be available.\n\n"
                      "Would you like to specify an RTL directory?");
        msgBox.setStandardButtons(QMessageBox::Yes | QMessageBox::No);
        msgBox.setDefaultButton(QMessageBox::No);
        
        if (msgBox.exec() == QMessageBox::Yes) {
            showRtlDirectoryDialog();
            return; // Restart the process after setting RTL directory
        }
    }
    
    // Continue with VCD loading...
    statusBar()->clearMessage();

    // Create and show progress bar in status bar
    QProgressBar *progressBar = new QProgressBar();
    progressBar->setRange(0, 0); // Indeterminate progress (spinning)
    progressBar->setMaximumWidth(200);
    progressBar->setTextVisible(false);
    statusBar()->addPermanentWidget(progressBar);

    statusLabel->setText("Loading VCD file...");

    // Disable UI during loading to prevent user interaction
    setEnabled(false);
    QApplication::processEvents(); // Force UI update

    // Use QtConcurrent to run parsing in background thread
    QFuture<bool> parseFuture = QtConcurrent::run([this, vcdToLoad]()
                                                  { return vcdParser->parseHeaderOnly(vcdToLoad); });

    // Create a watcher to handle completion
    QFutureWatcher<bool> *watcher = new QFutureWatcher<bool>(this);
    connect(watcher, &QFutureWatcher<bool>::finished, this, [this, progressBar, watcher, vcdToLoad, rtlProcessingSuccess]()
            {
        bool success = watcher->result();
        
        // Re-enable UI
        setEnabled(true);
        
        // Remove progress bar
        statusBar()->removeWidget(progressBar);
        delete progressBar;
        watcher->deleteLater();
        
        if (success) {
            QString statusMessage = QString("Loaded: %1 (%2 signals)").arg(QFileInfo(vcdToLoad).fileName()).arg(vcdParser->getSignals().size());
            if (rtlProcessingSuccess) {
                statusMessage += " - With RTL port information";
            } else {
                statusMessage += " - No RTL information";
            }
            
            statusLabel->setText(statusMessage);

            // Pass parser to waveform widget but don't load all signals
            waveformWidget->setVcdData(vcdParser);

            // Clear any existing signals from previous file
            waveformWidget->setVisibleSignals(QList<VCDSignal>());
        } else {
            QMessageBox::critical(this, "Error",
                                  "Failed to parse VCD file: " + vcdParser->getError());
            statusLabel->setText("Ready");
        } });

    watcher->setFuture(parseFuture);
}

QString MainWindow::findRtlDirectory(const QString &vcdFile)
{
    QFileInfo vcdInfo(vcdFile);
    QDir vcdDir = vcdInfo.dir();
    
    // Check for common RTL directory names
    QStringList rtlDirs = {"rtl", "RTL", "src", "source", "sources", "verilog", "sv"};
    
    for (const QString &dirName : rtlDirs) {
        if (vcdDir.exists(dirName)) {
            return vcdDir.filePath(dirName);
        }
    }
    
    // Check if current directory has RTL files
    QStringList rtlFilters = {"*.v", "*.sv"};
    if (!vcdDir.entryList(rtlFilters, QDir::Files).isEmpty()) {
        return vcdDir.path();
    }
    
    return "";
}

bool MainWindow::runVcdPortMapper(const QString &inputVcd, const QString &outputVcd, const QString &rtlDir)
{
    // Get the path to the Python script
    QString pythonScript = QCoreApplication::applicationDirPath() + "/vcd_port_mapper.py";
    
    // If script doesn't exist in application dir, try current dir
    if (!QFile::exists(pythonScript)) {
        pythonScript = "vcd_port_mapper.py";
    }
    
    if (!QFile::exists(pythonScript)) {
        qDebug() << "VCD port mapper script not found:" << pythonScript;
        return false;
    }
    
    // Prepare the command
    QStringList arguments;
    arguments << pythonScript << inputVcd << "-o" << outputVcd << "-r" << rtlDir;
    
    QProcess process;
    process.start("python", arguments);
    
    if (!process.waitForStarted()) {
        qDebug() << "Failed to start VCD port mapper";
        return false;
    }
    
    if (!process.waitForFinished(30000)) { // 30 second timeout
        qDebug() << "VCD port mapper timed out";
        return false;
    }
    
    if (process.exitCode() != 0) {
        qDebug() << "VCD port mapper failed:" << process.readAllStandardError();
        return false;
    }
    
    qDebug() << "VCD port mapper completed successfully";
    return true;
}

// Add the RTL processing functions:
bool MainWindow::processVcdWithRtl(const QString &vcdFile)
{
    QString rtlDir = findRtlDirectory(vcdFile);
    if (rtlDir.isEmpty()) {
        return false;
    }
    
    return runVcdPortMapper(vcdFile, tempVcdFilePath, rtlDir);
}

void MainWindow::zoomIn()
{
    waveformWidget->zoomIn();
}

void MainWindow::zoomOut()
{
    waveformWidget->zoomOut();
}

void MainWindow::zoomFit()
{
    waveformWidget->zoomFit();
}

void MainWindow::updateTimeDisplay(int time)
{
    timeLabel->setText(QString("Time: %1").arg(time));
}

void MainWindow::about()
{
    QMessageBox::about(this, "About VCD Wave Viewer",
                       "VCD Wave Viewer\n\n"
                       "A professional waveform viewer for Value Change Dump (VCD) files.\n"
                       "Built with Qt C++\n\n"
                       "Features:\n"
                       "- Unified signal names and waveform display\n"
                       "- Dark theme\n"
                       "- Drag to reorder signals\n"
                       "- Professional signal selection dialog\n"
                       "- Mouse wheel navigation");
}

void MainWindow::toggleBusDisplayFormat()
{
    if (sender() == busHexAction)
    {
        waveformWidget->setBusDisplayFormat(WaveformWidget::Hex);
        busHexAction->setChecked(true);
        busBinaryAction->setChecked(false);
    }
    else if (sender() == busBinaryAction)
    {
        waveformWidget->setBusDisplayFormat(WaveformWidget::Binary);
        busHexAction->setChecked(false);
        busBinaryAction->setChecked(true);
    }
}

void MainWindow::setBusHexFormat()
{
    waveformWidget->setBusDisplayFormat(WaveformWidget::Hex);
    updateBusFormatActions();
}

void MainWindow::setBusBinaryFormat()
{
    waveformWidget->setBusDisplayFormat(WaveformWidget::Binary);
    updateBusFormatActions();
}

void MainWindow::setBusOctalFormat()
{
    waveformWidget->setBusDisplayFormat(WaveformWidget::Octal);
    updateBusFormatActions();
}

void MainWindow::setBusDecimalFormat()
{
    waveformWidget->setBusDisplayFormat(WaveformWidget::Decimal);
    updateBusFormatActions();
}

void MainWindow::updateBusFormatActions()
{
    busHexAction->setChecked(false);
    busBinaryAction->setChecked(false);
    busOctalAction->setChecked(false);
    busDecimalAction->setChecked(false);

    switch (waveformWidget->getBusDisplayFormat())
    {
    case WaveformWidget::Hex:
        busHexAction->setChecked(true);
        break;
    case WaveformWidget::Binary:
        busBinaryAction->setChecked(true);
        break;
    case WaveformWidget::Octal:
        busOctalAction->setChecked(true);
        break;
    case WaveformWidget::Decimal:
        busDecimalAction->setChecked(true);
        break;
    }
}

void MainWindow::setupNavigationControls()
{
    // Create navigation controls
    QWidget *navWidget = new QWidget();
    QHBoxLayout *navLayout = new QHBoxLayout(navWidget);
    navLayout->setContentsMargins(5, 0, 5, 0);
    navLayout->setSpacing(3); // Reduced spacing between widgets

    QLabel *navLabel = new QLabel("Navigate:");
    navigationModeCombo = new QComboBox();
    QFont boldFont;
    boldFont.setWeight(QFont::Bold);

    navigationModeCombo->addItem("⇄");
    navigationModeCombo->addItem("↱");
    navigationModeCombo->addItem("↳"); 

    // Set the font for each item
    navigationModeCombo->setItemData(0, boldFont, Qt::FontRole);
    navigationModeCombo->setItemData(1, boldFont, Qt::FontRole);
    navigationModeCombo->setItemData(2, boldFont, Qt::FontRole);
    
    // Make combo box smaller
    navigationModeCombo->setMaximumWidth(60);
    navigationModeCombo->setMaximumHeight(22);

    // Create smaller prev/next buttons
    prevValueButton = new QPushButton("◀");
    nextValueButton = new QPushButton("▶");
    
    // Set smaller button sizes
    prevValueButton->setFixedSize(22, 22);
    nextValueButton->setFixedSize(22, 22);
    
    // Set smaller font for buttons
    QFont smallFont = prevValueButton->font();
    smallFont.setPointSize(8);
    prevValueButton->setFont(smallFont);
    nextValueButton->setFont(smallFont);

    prevValueButton->setEnabled(false);
    nextValueButton->setEnabled(false);

    // Create time input field
    QLabel *timeLabel = new QLabel("Time:");
    QLineEdit *timeInput = new QLineEdit();
    
    // Set initial placeholder with current time (start with 0)
    timeInput->setPlaceholderText("Time: 0");
    
    timeInput->setMaximumWidth(80); // Slightly wider to fit "Time: 1234"
    timeInput->setMaximumHeight(22);
    
    // Set validator to accept only numbers
    QIntValidator *validator = new QIntValidator(0, 1000000000, this);
    timeInput->setValidator(validator);

    // Connect time input - when Enter is pressed, move cursor to that time
    connect(timeInput, &QLineEdit::returnPressed, this, [this, timeInput]() {
        bool ok;
        int time = timeInput->text().toInt(&ok);
        if (ok) {
            // Move cursor to the specified time
            waveformWidget->navigateToTime(time);
            // Update the time display
            updateTimeDisplay(time);
            // Clear the input field and immediately update placeholder
            timeInput->clear();
            timeInput->clearFocus(); // Remove focus so placeholder is visible
            
            // Force update the placeholder with the new time immediately
            QString timeText = QString("Time: %1").arg(time);
            timeInput->setPlaceholderText(timeText);
        }
    });

    // Connect to update the placeholder text with YELLOW TIMELINE CURSOR time
    connect(waveformWidget, &WaveformWidget::cursorTimeChanged, this, [timeInput](int time) {
        // Always update the placeholder to match the cursor time
        QString timeText = QString("Time: %1").arg(time);
        timeInput->setPlaceholderText(timeText);
    });

    // FIX: Use simpler connection syntax
    connect(navigationModeCombo, SIGNAL(currentIndexChanged(int)),
            this, SLOT(onNavigationModeChanged(int)));
    connect(prevValueButton, &QPushButton::clicked, this, &MainWindow::onPrevValueClicked);
    connect(nextValueButton, &QPushButton::clicked, this, &MainWindow::onNextValueClicked);

    navLayout->addWidget(navLabel);
    navLayout->addWidget(navigationModeCombo);
    navLayout->addWidget(prevValueButton);
    navLayout->addWidget(nextValueButton);
    navLayout->addWidget(timeLabel);
    navLayout->addWidget(timeInput);
    navLayout->addStretch();

    // Add to main toolbar
    mainToolBar->addWidget(navWidget);
}


void MainWindow::onNavigationModeChanged(int index)
{
    // Only 3 modes now: 0=ValueChange, 1=SignalRise, 2=SignalFall
    if (index >= 0 && index <= 2) {
        waveformWidget->setNavigationMode(static_cast<WaveformWidget::NavigationMode>(index));
        updateNavigationButtons();
    }
}

void MainWindow::onPrevValueClicked()
{
    waveformWidget->navigateToPreviousEvent();
    updateNavigationButtons();
}

void MainWindow::onNextValueClicked()
{
    waveformWidget->navigateToNextEvent();
    updateNavigationButtons();
}

void MainWindow::updateNavigationButtons()
{
    bool hasSelection = !waveformWidget->getSelectedItemIndices().isEmpty();
    
    if (hasSelection) {
        bool hasPrev = waveformWidget->hasPreviousEvent();
        bool hasNext = waveformWidget->hasNextEvent();

        prevValueButton->setEnabled(hasPrev);
        nextValueButton->setEnabled(hasNext);
        
        qDebug() << "Navigation buttons - HasPrev:" << hasPrev << "HasNext:" << hasNext;
    } else {
        prevValueButton->setEnabled(false);
        nextValueButton->setEnabled(false);
    }
}#include "vcdparser.h"
#include <QRegularExpression>
#include <QDebug>

VCDParser::VCDParser(QObject *parent)
    : QObject(parent), endTime(0)
{
}

VCDParser::~VCDParser()
{
}



QString VCDParser::generateFullName(const QString &scope, const QString &name)
{
    if (scope.isEmpty()) {
        return name;
    }
    return scope + "." + name;
}

bool VCDParser::parseFile(const QString &filename)
{
    // For now, use header-only parsing for performance
    return parseHeaderOnly(filename);
}

bool VCDParser::parseHeaderOnly(const QString &filename)
{
    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        errorString = "Cannot open file: " + filename;
        return false;
    }

    vcdFilename = filename;
    QTextStream stream(&file);
    
    vcdSignals.clear();
    identifierMap.clear();
    fullNameMap.clear();  // ADD THIS
    currentScope.clear();
    valueChanges.clear();
    loadedSignals.clear();
    endTime = 0;

    if (!parseHeader(stream)) {
        file.close();
        return false;
    }

    file.close();

    qDebug() << "VCD header parsing completed";
    qDebug() << "Signals found:" << vcdSignals.size();
    qDebug() << "Unique identifiers:" << identifierMap.size();
    qDebug() << "Unique full names:" << fullNameMap.size();

    return true;
}

bool VCDParser::parseHeader(QTextStream &stream)
{
    QRegularExpression scopeRegex("^\\$scope\\s+(\\w+)\\s+(\\S+)\\s*\\$end$");
    QRegularExpression varRegex("^\\$var\\s+(\\w+)\\s+(\\d+)\\s+(\\S+)\\s+(.+)\\s*\\$end$");
    QRegularExpression timescaleRegex("^\\$timescale\\s+(\\S+)\\s*\\$end$");

    while (!stream.atEnd()) {
        QString line = stream.readLine().trimmed();

        if (line.startsWith("$date")) {
            // Skip date section
            while (!stream.atEnd() && !line.contains("$end")) {
                line = stream.readLine().trimmed();
            }
        }
        else if (line.startsWith("$version")) {
            // Skip version section
            while (!stream.atEnd() && !line.contains("$end")) {
                line = stream.readLine().trimmed();
            }
        }
        else if (line.startsWith("$comment")) {
            // Skip comment section
            while (!stream.atEnd() && !line.contains("$end")) {
                line = stream.readLine().trimmed();
            }
        }
        else if (line.startsWith("$timescale")) {
            parseTimescale(line);
        }
        else if (line.startsWith("$scope")) {
            parseScopeLine(line);
        }
        else if (line.startsWith("$var")) {
            parseVarLine(line);
        }
        else if (line.startsWith("$upscope")) {
            // Move up one scope level
            int lastDot = currentScope.lastIndexOf('.');
            if (lastDot != -1) {
                currentScope = currentScope.left(lastDot);
            } else {
                currentScope.clear();
            }
        }
        else if (line.startsWith("$enddefinitions")) {
            // End of header
            break;
        }
        else if (line.startsWith("#")) {
            // We reached the value change section, stop header parsing
            break;
        }
    }

    return true;
}


// Update the value change functions to use fullName
bool VCDParser::loadSignalsData(const QList<QString> &fullNames)
{
    if (fullNames.isEmpty()) {
        return true;
    }

    QFile file(vcdFilename);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        errorString = "Cannot open file for signal loading: " + vcdFilename;
        return false;
    }

    QTextStream stream(&file);
    
    // Convert to set for fast lookup - but we need to map fullNames back to identifiers
    QSet<QString> signalsToLoad;
    for (const QString &fullName : fullNames) {
        if (fullNameMap.contains(fullName) && !loadedSignals.contains(fullName)) {
            QString identifier = fullNameMap[fullName].identifier;
            signalsToLoad.insert(identifier);
            // Initialize empty value changes using fullName as key
            valueChanges[fullName] = QVector<VCDValueChange>();
        }
    }

    if (signalsToLoad.isEmpty()) {
        file.close();
        return true; // All signals already loaded
    }

    qDebug() << "Loading data for" << signalsToLoad.size() << "signals";

    if (!parseValueChangesForSignals(stream, signalsToLoad)) {
        file.close();
        return false;
    }

    file.close();

    // Mark signals as loaded using fullName
    for (const QString &fullName : fullNames) {
        if (fullNameMap.contains(fullName)) {
            loadedSignals.insert(fullName);
        }
    }

    qDebug() << "Successfully loaded data for" << signalsToLoad.size() << "signals";
    return true;
}


bool VCDParser::parseValueChangesForSignals(QTextStream &stream, const QSet<QString> &signalsToLoad)
{
    QRegularExpression timestampRegex("^#(\\d+)$");
    QRegularExpression valueChangeRegex("^([01xXzZrb])(\\S+)$");
    QRegularExpression vectorValueRegex("^[bB]([01xXzZ]+)\\s+(\\S+)$");

    int currentTime = 0;
    int changesFound = 0;

    // Create a reverse mapping from identifier to all possible fullNames
    QMap<QString, QList<QString>> identifierToFullNames;
    for (const auto &signal : vcdSignals) {
        identifierToFullNames[signal.identifier].append(signal.fullName);
    }

    while (!stream.atEnd()) {
        QString line = stream.readLine().trimmed();

        if (line.isEmpty()) continue;

        // Check for timestamp
        QRegularExpressionMatch timestampMatch = timestampRegex.match(line);
        if (timestampMatch.hasMatch()) {
            currentTime = timestampMatch.captured(1).toInt();
            endTime = qMax(endTime, currentTime);
            continue;
        }

        // Handle scalar value changes (0, 1, x, z)
        QRegularExpressionMatch valueMatch = valueChangeRegex.match(line);
        if (valueMatch.hasMatch()) {
            QString value = valueMatch.captured(1).toUpper();
            QString identifier = valueMatch.captured(2);

            if (signalsToLoad.contains(identifier)) {
                // Apply this value change to ALL signals with this identifier
                if (identifierToFullNames.contains(identifier)) {
                    for (const QString &fullName : identifierToFullNames[identifier]) {
                        VCDValueChange change;
                        change.timestamp = currentTime;
                        change.value = value;
                        valueChanges[fullName].append(change);
                        changesFound++;
                    }
                }
            }
            continue;
        }

        // Handle vector value changes (binary)
        QRegularExpressionMatch vectorMatch = vectorValueRegex.match(line);
        if (vectorMatch.hasMatch()) {
            QString value = vectorMatch.captured(1);
            QString identifier = vectorMatch.captured(2);

            if (signalsToLoad.contains(identifier)) {
                // Apply this value change to ALL signals with this identifier
                if (identifierToFullNames.contains(identifier)) {
                    for (const QString &fullName : identifierToFullNames[identifier]) {
                        VCDValueChange change;
                        change.timestamp = currentTime;
                        change.value = value;
                        valueChanges[fullName].append(change);
                        changesFound++;
                    }
                }
            }
            continue;
        }

        // Handle real value changes
        if (line.startsWith("r")) {
            QStringList parts = line.split(" ", Qt::SkipEmptyParts);
            if (parts.size() >= 2) {
                QString value = parts[0].mid(1); // Remove 'r' prefix
                QString identifier = parts[1];
                
                if (signalsToLoad.contains(identifier)) {
                    // Apply this value change to ALL signals with this identifier
                    if (identifierToFullNames.contains(identifier)) {
                        for (const QString &fullName : identifierToFullNames[identifier]) {
                            VCDValueChange change;
                            change.timestamp = currentTime;
                            change.value = value;
                            valueChanges[fullName].append(change);
                            changesFound++;
                        }
                    }
                }
            }
        }
    }

    qDebug() << "Found" << changesFound << "value changes for requested signals";
    return true;
}
QVector<VCDValueChange> VCDParser::getValueChangesForSignal(const QString &fullName)
{
    // If signal data is not loaded yet, load it now
    if (!loadedSignals.contains(fullName)) {
        QList<QString> signalsToLoad = {fullName};
        loadSignalsData(signalsToLoad);
    }
    
    return valueChanges.value(fullName);
}

void VCDParser::parseTimescale(const QString &line)
{
    QRegularExpression regex("^\\$timescale\\s+(\\S+)\\s*\\$end$");
    QRegularExpressionMatch match = regex.match(line);
    if (match.hasMatch()) {
        timescale = match.captured(1);
        qDebug() << "Timescale:" << timescale;
    }
}

void VCDParser::parseScopeLine(const QString &line)
{
    QRegularExpression regex("^\\$scope\\s+(\\w+)\\s+(\\S+)\\s*\\$end$");
    QRegularExpressionMatch match = regex.match(line);
    if (match.hasMatch()) {
        QString scopeType = match.captured(1);
        QString scopeName = match.captured(2);
        
        if (!currentScope.isEmpty()) {
            currentScope += "." + scopeName;
        } else {
            currentScope = scopeName;
        }
    }
}

void VCDParser::parseVarLine(const QString &line)
{
    QRegularExpression regex("^\\$var\\s+(\\w+)\\s+(\\d+)\\s+(\\S+)\\s+(.+)\\s*\\$end$");
    QRegularExpressionMatch match = regex.match(line);
    
    if (match.hasMatch()) {
        VCDSignal signal;
        signal.type = match.captured(1);
        signal.width = match.captured(2).toInt();
        signal.identifier = match.captured(3);
        
        QString signalName = match.captured(4).trimmed();
        signal.name = signalName;
        signal.scope = currentScope;
        signal.fullName = generateFullName(currentScope, signalName);

        vcdSignals.append(signal);
        
        // Store in both maps
        identifierMap[signal.identifier] = signal;
        fullNameMap[signal.fullName] = signal;
        
        // qDebug() << "Parsed signal - Full:" << signal.fullName 
        //          << "ID:" << signal.identifier 
        //          << "Scope:" << signal.scope 
        //          << "Name:" << signal.name;
    }
}#include "waveformwidget.h"
#include <QScrollBar>
#include <QWheelEvent>
#include <QMouseEvent>
#include <QResizeEvent>
#include <QPaintEvent>
#include <QContextMenuEvent>
#include <QKeyEvent>
#include <QInputDialog>
#include <QApplication>
#include <cmath>

WaveformWidget::WaveformWidget(QWidget *parent)
    : QWidget(parent),
      vcdParser(nullptr),
      timeScale(1.0),
      timeOffset(0),
      signalNamesWidth(250),
      valuesColumnWidth(120),
      timeMarkersHeight(30),
      topMargin(0),
      signalHeight(24), // Only signalHeight remains
      lineWidth(1),
      isDragging(false),
      isDraggingItem(false),
      dragItemIndex(-1),
      dragStartX(0),
      dragStartOffset(0),
      dragStartY(0),
      lastSelectedItem(-1),
      busDisplayFormat(Hex),
      draggingNamesSplitter(false),
      draggingValuesSplitter(false),
      cursorTime(0),
      showCursor(true),
      verticalOffset(0),
      isSearchActive(false),
      MAX_CACHED_SIGNALS(1000)
{
    qDebug() << "WaveformWidget constructor started";
    setFocusPolicy(Qt::StrongFocus);
    setMouseTracking(true);

    qDebug() << "Creating scrollbars...";

    // In the constructor, update the horizontal scrollbar connection:
    horizontalScrollBar = new QScrollBar(Qt::Horizontal, this);
    connect(horizontalScrollBar, &QScrollBar::valueChanged, [this](int value)
            {
    timeOffset = value;
    update(); });

    // Add vertical scrollbar
    verticalScrollBar = new QScrollBar(Qt::Vertical, this);
    connect(verticalScrollBar, &QScrollBar::valueChanged, [this](int value)
            {
        verticalOffset = value;
        
        update(); });
    qDebug() << "WaveformWidget constructor completed";
}

void WaveformWidget::setVcdData(VCDParser *parser)
{
    vcdParser = parser;
    displayItems.clear();

    // Reset zoom to safe levels when loading new data
    if (timeScale > 100.0 || timeScale < 0.01)
    {
        timeScale = 1.0;
        timeOffset = 0;
    }

    selectedItems.clear();
    lastSelectedItem = -1;

    // Apply zoom fit automatically when VCD data is loaded
    if (vcdParser && vcdParser->getEndTime() > 0)
    {
        zoomFit();
    }
    else
    {
        updateScrollBar();
    }

    update();
}

const DisplayItem *WaveformWidget::getItem(int index) const
{
    if (index >= 0 && index < displayItems.size())
    {
        return &displayItems[index];
    }
    return nullptr;
}

void WaveformWidget::removeSelectedSignals()
{
    if (selectedItems.isEmpty())
        return;

    // Remove items in reverse order
    QList<int> indices = selectedItems.values();
    std::sort(indices.begin(), indices.end(), std::greater<int>());

    for (int index : indices)
    {
        if (index >= 0 && index < displayItems.size())
        {
            displayItems.removeAt(index);
        }
    }

    selectedItems.clear();
    lastSelectedItem = -1;
    update();
    emit itemSelected(-1);
}

void WaveformWidget::selectAllSignals()
{
    selectedItems.clear();
    for (int i = 0; i < displayItems.size(); i++)
    {
        selectedItems.insert(i);
    }
    lastSelectedItem = displayItems.size() - 1;
    update();
    emit itemSelected(selectedItems.isEmpty() ? -1 : *selectedItems.begin());
}

void WaveformWidget::zoomIn()
{
    if (timeScale >= 50.0) return;

    // Get mouse position in widget coordinates
    QPoint mousePos = mapFromGlobal(QCursor::pos());
    int waveformStartX = signalNamesWidth + valuesColumnWidth;
    
    qDebug() << "=== ZOOM IN ===";
    qDebug() << "Mouse pos:" << mousePos;
    qDebug() << "Waveform start X:" << waveformStartX;

    // Only zoom to mouse if it's in the waveform area
    if (mousePos.x() >= waveformStartX && mousePos.y() >= timeMarkersHeight) 
    {
        // Calculate mouse position relative to waveform area
        int mouseXInWaveform = mousePos.x() - waveformStartX;
        
        // The key calculation: what time is currently under the mouse?
        // time = (pixel_position + scroll_offset) / scale
        double timeUnderMouse = (mouseXInWaveform + timeOffset) / timeScale;
        
        qDebug() << "Mouse in waveform - X:" << mouseXInWaveform;
        qDebug() << "Time under mouse:" << timeUnderMouse;
        qDebug() << "Before - Scale:" << timeScale << "Offset:" << timeOffset;

        // Apply zoom
        double oldScale = timeScale;
        timeScale *= 1.2;
        timeScale = qMin(50.0, timeScale);

        // After zoom, we want the same time to be under the mouse
        // So we adjust the offset: new_offset = time * new_scale - mouse_x
        timeOffset = timeUnderMouse * timeScale - mouseXInWaveform;
        
        qDebug() << "After - Scale:" << timeScale << "Offset:" << timeOffset;
    }
    else
    {
        // Default zoom (center-based)
        timeScale = qMin(50.0, timeScale * 1.2);
        qDebug() << "Default zoom - New scale:" << timeScale;
    }

    updateScrollBar();
    update();
}

void WaveformWidget::zoomOut()
{
    // Calculate the maximum scale allowed (zoom fit level)
    double maxScaleForZoomOut = calculateZoomFitScale();
    
    // If we're already at or beyond zoom fit level, don't zoom out further
    if (timeScale <= maxScaleForZoomOut) {
        // Optional: Snap to exact zoom fit scale
        timeScale = maxScaleForZoomOut;
        updateScrollBar();
        update();
        return;
    }

    // Always use mouse position
    QPoint mousePos = mapFromGlobal(QCursor::pos());
    int waveformStartX = signalNamesWidth + valuesColumnWidth;
    int mouseXInWaveform = mousePos.x() - waveformStartX;
    
    if (mouseXInWaveform < 0) mouseXInWaveform = 0;
    
    double timeUnderMouse = (mouseXInWaveform + timeOffset) / timeScale;
    
    double oldScale = timeScale;
    timeScale /= 1.2;
    
    // Don't zoom out beyond zoom fit level
    timeScale = qMax(maxScaleForZoomOut, timeScale);
    timeScale = qMax(0.1, timeScale); // Still respect absolute minimum
    
    timeOffset = timeUnderMouse * timeScale - mouseXInWaveform;
    
    // Clamp offset to prevent negative timeline
    if (timeOffset < 0) {
        timeOffset = 0;
    }

    updateScrollBar();
    update();
}

void WaveformWidget::zoomFit()
{
    if (!vcdParser || vcdParser->getEndTime() <= 0)
    {
        timeScale = 1.0;
        timeOffset = 0;
        updateScrollBar();
        update();
        return;
    }

    int availableWidth = width() - signalNamesWidth - valuesColumnWidth - 20;

    // Use the same margins as scrolling - UPDATE THIS LINE:
    const int LEFT_MARGIN = 0; // -10 time units (negative time)
    const int RIGHT_MARGIN = 10; // 100 time units after end

    int totalTimeRange = vcdParser->getEndTime() + RIGHT_MARGIN - LEFT_MARGIN; // Note: subtract LEFT_MARGIN because it's negative

    if (availableWidth <= 10)
    {
        timeScale = 1.0;
    }
    else if (totalTimeRange <= 0)
    {
        timeScale = 1.0;
    }
    else
    {
        timeScale = static_cast<double>(availableWidth) / totalTimeRange;
    }

    timeScale = qMax(0.001, qMin(1000.0, timeScale));   
    timeOffset = 0;

    updateScrollBar();
    update();
}

void WaveformWidget::resetSignalColors()
{
    signalColors.clear();
    update();
}

void WaveformWidget::setBusDisplayFormat(BusFormat format)
{
    busDisplayFormat = format;
    update();
}

void WaveformWidget::drawSignalValuesColumn(QPainter &painter, int cursorTime)
{
    if (!showCursor || cursorTime < 0 || !vcdParser)
        return;

    int valuesColumnStart = signalNamesWidth;

    // Draw values column background
    painter.fillRect(valuesColumnStart, 0, valuesColumnWidth, height(), QColor(0, 0, 0));

    // Draw values splitter
    // painter.fillRect(valuesColumnStart + valuesColumnWidth - 1, 0, 2, height(), QColor(100, 100, 100));

    // Draw pinned header (always visible)
    painter.fillRect(valuesColumnStart, 0, valuesColumnWidth, timeMarkersHeight, QColor(30, 30, 30)); // Value Column | Header Color
    painter.setPen(QPen(Qt::white));
    painter.drawText(valuesColumnStart + 5, timeMarkersHeight - 8, "Value");

    // Set up clipping to exclude pinned areas from scrolling
    painter.setClipRect(valuesColumnStart, timeMarkersHeight, valuesColumnWidth, height() - timeMarkersHeight);

    // FIXED: Use same starting position as names column
    int currentY = timeMarkersHeight - verticalOffset;

    for (int i = 0; i < displayItems.size(); i++)
    {
        const auto &item = displayItems[i];
        int itemHeight = (item.type == DisplayItem::Signal) ? signalHeight : 30;

        // Skip drawing if item is outside visible area
        if (currentY + itemHeight <= timeMarkersHeight)
        {
            currentY += itemHeight;
            continue;
        }
        if (currentY >= height())
        {
            break;
        }

        // Draw background for this row
        bool isSelected = selectedItems.contains(i);
        bool isSearchMatch = searchResults.contains(i);

        if (isSelected)
        {
            painter.fillRect(valuesColumnStart, currentY, valuesColumnWidth, itemHeight, QColor(60, 60, 90));
        }
        else if (isSearchActive && isSearchMatch)
        {
            painter.fillRect(valuesColumnStart, currentY, valuesColumnWidth, itemHeight, QColor(80, 80, 120, 150));
        }
        else if (i % 2 == 0)
        {
            painter.fillRect(valuesColumnStart, currentY, valuesColumnWidth, itemHeight, QColor(0, 0, 0)); // Value Column | Color 1
        }
        else
        {
            painter.fillRect(valuesColumnStart, currentY, valuesColumnWidth, itemHeight, QColor(0, 0, 0)); // Value Column | Color 2
        }

        if (item.type == DisplayItem::Signal)
        {
            const VCDSignal &signal = item.signal.signal;

            // FIX: Use the signal's fullName to get the value
            QString value = getSignalValueAtTime(signal.fullName, cursorTime);

            // Format the value based on signal type
            QString displayValue;
            if (signal.width > 1)
            {
                displayValue = formatBusValue(value);
            }
            else
            {
                displayValue = value.toUpper();
            }

            // Center text vertically within the item
            QFontMetrics fm(painter.font());
            int textY = currentY + (itemHeight + fm.ascent() - fm.descent()) / 2;

            painter.setPen(QPen(Qt::white));
            painter.drawText(valuesColumnStart + 5, textY, displayValue);
        }

        // Draw horizontal separator
        painter.setPen(QPen(QColor(80, 80, 80)));
        painter.drawLine(valuesColumnStart, currentY + itemHeight,
                         valuesColumnStart + valuesColumnWidth, currentY + itemHeight);

        currentY += itemHeight;
    }

    // Reset clipping
    painter.setClipping(false);
}

void WaveformWidget::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event)

    // Global safety check - reset if zoom is completely unreasonable
    if (timeScale > 1000.0 || timeScale < 0.001)
    {
        qDebug() << "Global emergency: Resetting unreasonable zoom:" << timeScale;
        timeScale = 1.0;
        timeOffset = 0;
    }

    QPainter painter(this);

    // Fill entire background with dark theme
    painter.fillRect(rect(), QColor(0, 0, 0));

    if (!vcdParser || displayItems.isEmpty())
    {
        painter.fillRect(rect(), QColor(45, 45, 48));
        painter.drawText(rect(), Qt::AlignCenter, "No signals selected");
        return;
    }

    drawSignalNamesColumn(painter);
    drawSignalValuesColumn(painter, cursorTime); // FIX: Pass cursorTime here
    drawWaveformArea(painter);
    drawTimeCursor(painter);
}

void WaveformWidget::drawSignalNamesColumn(QPainter &painter)
{
    // Draw signal names column background
    painter.fillRect(0, 0, signalNamesWidth, height(), QColor(0, 0, 0)); // Signal Name Column | Background color

    // Draw names splitter
    // painter.fillRect(signalNamesWidth - 1, 0, 2, height(), QColor(100, 100, 100));

    // Draw pinned header (always visible)
    painter.fillRect(0, 0, signalNamesWidth, timeMarkersHeight, QColor(30, 30, 30)); // Signal Name Column | Header Color
    painter.setPen(QPen(Qt::white));
    painter.drawText(5, timeMarkersHeight - 8, "Signal Name");

    // Set up clipping to exclude pinned areas from scrolling
    painter.setClipRect(0, timeMarkersHeight, signalNamesWidth, height() - timeMarkersHeight);

    // FIXED: Start drawing signals right below the timeline header
    int currentY = timeMarkersHeight - verticalOffset;

    for (int i = 0; i < displayItems.size(); i++)
    {
        const auto &item = displayItems[i];
        int itemHeight = (item.type == DisplayItem::Signal) ? signalHeight : 30;

        // Skip drawing if item is completely outside visible area
        if (currentY + itemHeight <= timeMarkersHeight)
        {
            currentY += itemHeight;
            continue;
        }
        if (currentY >= height())
        {
            break;
        }

        // Draw background based on selection and type
        bool isSelected = selectedItems.contains(i);
        bool isSearchMatch = searchResults.contains(i);

        if (isSelected)
        {
            painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(60, 60, 90));
        }
        else if (isSearchActive && isSearchMatch)
        {
            painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(80, 80, 120, 150));
        }
        else if (item.type == DisplayItem::Space)
        {
            painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(80, 160, 80, 120));
        }
        else if (i % 2 == 0)
        {
            painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(0, 0, 0)); // Signal Name Column | Color 1
        }
        else
        {
            painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(0, 0, 0)); // Signal Name Column | Color 2
        }

        // Draw item name with appropriate styling
        if (isSelected)
        {
            painter.setPen(QPen(Qt::white));
        }
        else if (isSearchActive && isSearchMatch)
        {
            painter.setPen(QPen(QColor(200, 200, 255)));
        }
        else if (item.type == DisplayItem::Space)
        {
            painter.setPen(QPen(QColor(150, 255, 150)));
        }
        else
        {
            painter.setPen(QPen(Qt::white));
        }

        QString displayName = item.getName();
        int textIndent = 5;

        // Center text vertically within the item
        QFontMetrics fm(painter.font());
        int textY = currentY + (itemHeight + fm.ascent() - fm.descent()) / 2;

        if (item.type == DisplayItem::Signal)
        {
            // For signals: draw name on left and bit range on right
            const VCDSignal &signal = item.signal.signal;
            int msb = signal.width - 1;
            QString bitRangeText = QString("[%1:0]").arg(msb);
            int bitRangeTextWidth = fm.horizontalAdvance(bitRangeText);
            
            // Draw signal name
            painter.drawText(textIndent, textY, displayName);
            
            // Draw bit range at the right end of the column
            int bitRangeX = signalNamesWidth - bitRangeTextWidth - 5; // 5px padding from right edge
            painter.setPen(QPen(QColor(180, 180, 180))); // Gray color for bit range
            painter.drawText(bitRangeX, textY, bitRangeText);
            
            // Reset pen color for next items
            if (isSelected)
            {
                painter.setPen(QPen(Qt::white));
            }
            else if (isSearchActive && isSearchMatch)
            {
                painter.setPen(QPen(QColor(200, 200, 255)));
            }
            else if (item.type == DisplayItem::Space)
            {
                painter.setPen(QPen(QColor(150, 255, 150)));
            }
            else
            {
                painter.setPen(QPen(Qt::white));
            }
        }
        else
        {
            // For spaces: just draw the name normally
            painter.drawText(textIndent, textY, displayName);
        }

        // Draw horizontal separator
        painter.setPen(QPen(QColor(80, 80, 80)));
        painter.drawLine(0, currentY + itemHeight, signalNamesWidth, currentY + itemHeight);

        currentY += itemHeight;
    }

    // Reset clipping
    painter.setClipping(false);
}

// void WaveformWidget::drawSignalNamesColumn(QPainter &painter)
// {
//     // Draw signal names column background
//     painter.fillRect(0, 0, signalNamesWidth, height(), QColor(0, 0, 0));

//     // Draw names splitter
//     // painter.fillRect(signalNamesWidth - 1, 0, 2, height(), QColor(100, 100, 100));

//     // Draw pinned header (always visible)
//     painter.fillRect(0, 0, signalNamesWidth, timeMarkersHeight, QColor(30, 30, 30)); // Signal Name Column | Header Color
//     painter.setPen(QPen(Qt::white));
//     painter.drawText(5, timeMarkersHeight - 8, "Signal Name");

//     // Set up clipping to exclude pinned areas from scrolling
//     painter.setClipRect(0, timeMarkersHeight, signalNamesWidth, height() - timeMarkersHeight);

//     // FIXED: Start drawing signals right below the timeline header
//     int currentY = timeMarkersHeight - verticalOffset;

//     for (int i = 0; i < displayItems.size(); i++)
//     {
//         const auto &item = displayItems[i];
//         int itemHeight = (item.type == DisplayItem::Signal) ? signalHeight : 30;

//         // Skip drawing if item is completely outside visible area
//         if (currentY + itemHeight <= timeMarkersHeight)
//         {
//             currentY += itemHeight;
//             continue;
//         }
//         if (currentY >= height())
//         {
//             break;
//         }

//         // Draw background based on selection and type
//         bool isSelected = selectedItems.contains(i);
//         bool isSearchMatch = searchResults.contains(i);

//         if (isSelected)
//         {
//             painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(60, 60, 90));
//         }
//         else if (isSearchActive && isSearchMatch)
//         {
//             painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(80, 80, 120, 150));
//         }
//         else if (item.type == DisplayItem::Space)
//         {
//             painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(80, 160, 80, 120));
//         }
//         else if (i % 2 == 0)
//         {
//             painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(0, 0, 0)); // Signal Name Column | Color 1
//         }
//         else
//         {
//             painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(0, 0, 0)); // Signal Name Column | Color 2
//         }

//         // Draw item name with appropriate styling
//         if (isSelected)
//         {
//             painter.setPen(QPen(Qt::white));
//         }
//         else if (isSearchActive && isSearchMatch)
//         {
//             painter.setPen(QPen(QColor(200, 200, 255)));
//         }
//         else if (item.type == DisplayItem::Space)
//         {
//             painter.setPen(QPen(QColor(150, 255, 150)));
//         }
//         else
//         {
//             painter.setPen(QPen(Qt::white));
//         }

//         QString displayName = item.getName();
//         int textIndent = 5;

//         // Center text vertically within the item
//         QFontMetrics fm(painter.font());
//         int textY = currentY + (itemHeight + fm.ascent() - fm.descent()) / 2;
//         painter.drawText(textIndent, textY, displayName);

//         // Draw horizontal separator
//         painter.setPen(QPen(QColor(80, 80, 80)));
//         painter.drawLine(0, currentY + itemHeight, signalNamesWidth, currentY + itemHeight);

//         currentY += itemHeight;
//     }

//     // Reset clipping
//     painter.setClipping(false);
// }

void WaveformWidget::drawWaveformArea(QPainter &painter)
{
    int waveformStartX = signalNamesWidth + valuesColumnWidth;

    // Draw pinned timeline background
    painter.fillRect(waveformStartX, 0, width() - waveformStartX, timeMarkersHeight, QColor(30, 30, 30)); // Time Line Column | Header Color

    // Draw grid lines in timeline area
    painter.setPen(QPen(QColor(80, 80, 80), 1, Qt::DotLine));
    int startTime = xToTime(0);
    int endTime = xToTime(width() - waveformStartX);
    int timeStep = calculateTimeStep(startTime, endTime);

    for (int time = (startTime / timeStep) * timeStep; time <= endTime; time += timeStep)
    {
        int x = timeToX(time);
        painter.drawLine(waveformStartX + x, 0, waveformStartX + x, timeMarkersHeight);

        painter.setPen(QPen(Qt::white));
        painter.drawText(waveformStartX + x + 2, timeMarkersHeight - 5, QString::number(time));
        painter.setPen(QPen(QColor(80, 80, 80), 1, Qt::DotLine));
    }

    // Set up clipping for scrollable waveform area (exclude pinned timeline)
    painter.setClipRect(waveformStartX, timeMarkersHeight, width() - waveformStartX, height() - timeMarkersHeight);

    // FIXED: Apply translation that matches the columns
    painter.translate(waveformStartX, timeMarkersHeight - verticalOffset);

    // Draw background for scrollable area - use the full calculated height
    int totalHeight = calculateTotalHeight();
    painter.fillRect(0, 0, width() - waveformStartX, totalHeight, QColor(0, 0, 0));

    if (!displayItems.isEmpty())
    {
        drawSignals(painter);
    }

    // Reset translation and clipping
    painter.translate(-waveformStartX, -timeMarkersHeight + verticalOffset);
    painter.setClipping(false);
}

void WaveformWidget::drawTimeCursor(QPainter &painter)
{
    if (!showCursor || cursorTime < 0)
        return;

    int waveformStartX = signalNamesWidth + valuesColumnWidth;
    int cursorX = timeToX(cursorTime);

    // Only draw if cursor is within visible waveform area
    if (cursorX < 0 || cursorX > (width() - waveformStartX))
        return;

    // Calculate the height based on actual signals (stop at last signal)
    int totalSignalsHeight = timeMarkersHeight; // Start below timeline
    
    for (int i = 0; i < displayItems.size(); i++) {
        const auto &item = displayItems[i];
        int itemHeight = (item.type == DisplayItem::Signal) ? signalHeight : 30;
        totalSignalsHeight += itemHeight;
    }
    
    // Add some padding at the bottom
    totalSignalsHeight += 10;
    
    // Don't draw beyond the actual content height
    int drawHeight = qMin(totalSignalsHeight, height());

    // Draw vertical cursor line from timeline area to the last signal
    painter.setPen(QPen(Qt::yellow, 2, Qt::DashLine));
    painter.drawLine(waveformStartX + cursorX, timeMarkersHeight, waveformStartX + cursorX, drawHeight);
}

void WaveformWidget::drawSignals(QPainter &painter)
{
    // FIXED: Start at position 0 since we're already translated
    int currentY = 0;

    for (int i = 0; i < displayItems.size(); i++)
    {
        const auto &item = displayItems[i];
        int itemHeight = (item.type == DisplayItem::Signal) ? signalHeight : 30;

        // Skip drawing if item is completely outside visible area
        int visibleTop = verticalOffset;
        int visibleBottom = verticalOffset + (height() - timeMarkersHeight);

        if (currentY + itemHeight < visibleTop)
        {
            currentY += itemHeight;
            continue;
        }
        if (currentY > visibleBottom)
        {
            break;
        }

        if (item.type == DisplayItem::Signal)
        {
            const VCDSignal &signal = item.signal.signal;

            // FIXED: Draw at the currentY position (no additional offset needed)
            if (signal.width > 1)
            {
                drawBusWaveform(painter, signal, currentY);
            }
            else
            {
                drawSignalWaveform(painter, signal, currentY);
            }
        }

        currentY += itemHeight;
    }
}

void WaveformWidget::drawSignalWaveform(QPainter &painter, const VCDSignal &signal, int yPos)
{
    // Use lazy loading to get value changes
    const auto changes = vcdParser->getValueChangesForSignal(signal.fullName);
    if (changes.isEmpty())
        return;

    // Check if this signal is selected
    bool isSelected = false;
    for (int i = 0; i < displayItems.size(); i++) {
        if (selectedItems.contains(i) && 
            displayItems[i].type == DisplayItem::Signal && 
            displayItems[i].signal.signal.fullName == signal.fullName) {
            isSelected = true;
            break;
        }
    }

    // Use thicker line for selected signals
    int currentLineWidth = isSelected ? selectedLineWidth : lineWidth;

    // Emergency check for extreme zoom
    if (timeScale > 1000.0 || timeScale < 0.001)
    {
        qDebug() << "Emergency: Skipping waveform drawing due to extreme zoom:" << timeScale;
        return;
    }

    // Check if user has set a custom color
    bool hasCustomColor = signalColors.contains(signal.fullName);
    QColor customColor = hasCustomColor ? signalColors[signal.fullName] : QColor();

    // Hardcoded small offset - 3 pixels from top and bottom
    int signalTop = yPos + 3;
    int signalBottom = yPos + signalHeight - 3;
    int signalMidY = yPos + signalHeight / 2;
    int highLevel = signalTop;    // Top of the waveform area
    int lowLevel = signalBottom;  // Bottom of the waveform area
    int middleLevel = signalMidY; // Middle for X/Z values

    int prevTime = 0;
    QString prevValue = "0";
    int prevX = timeToX(prevTime);

    for (const auto &change : changes)
    {
        int currentX = timeToX(change.timestamp);

        // Determine color for the HORIZONTAL segment
        QColor horizontalColor;

        bool prevIsX = (prevValue == "x" || prevValue == "X");
        bool prevIsZ = (prevValue == "z" || prevValue == "Z");
        bool isX = (change.value == "x" || change.value == "X");
        bool isZ = (change.value == "z" || change.value == "Z");

        // If user has chosen a custom color, use it for all horizontal segments
        if (hasCustomColor)
        {
            horizontalColor = customColor;
        }
        else
        {
            // No custom color - use value-based colors for horizontal segments
            if (prevIsX)
            {
                horizontalColor = QColor(255, 0, 0); // Red for X
            }
            else if (prevIsZ)
            {
                horizontalColor = QColor(255, 165, 0); // Orange for Z
            }
            else if (prevValue == "0")
            {
                horizontalColor = QColor(0x01, 0xFF, 0xFF); // Cyan for 0
            }
            else if (prevValue == "1")
            {
                horizontalColor = QColor(0, 255, 0); // Green for 1
            }
            else
            {
                horizontalColor = QColor(0xFF, 0xE6, 0xCD); // Default for other values
            }
        }

        // Draw the HORIZONTAL segment based on previous value - use currentLineWidth
        painter.setPen(QPen(horizontalColor, currentLineWidth));
        if (prevIsX || prevIsZ)
        {
            // Previous value was X or Z - draw at middle level
            painter.drawLine(prevX, middleLevel, currentX, middleLevel);
        }
        else if (prevValue == "1")
        {
            painter.drawLine(prevX, highLevel, currentX, highLevel);
        }
        else
        {
            // Previous value was zero - draw at low level
            painter.drawLine(prevX, lowLevel, currentX, lowLevel);
        }

        // Draw VERTICAL transition line if value changed
        if (prevValue != change.value)
        {
            int fromY, toY;

            // Determine starting Y position based on PREVIOUS value
            if (prevIsX || prevIsZ)
            {
                fromY = middleLevel;
            }
            else if (prevValue == "1")
            {
                fromY = highLevel;
            }
            else
            {
                fromY = lowLevel;
            }

            // Determine ending Y position based on CURRENT value
            if (isX || isZ)
            {
                toY = middleLevel;
            }
            else if (change.value == "1")
            {
                toY = highLevel;
            }
            else
            {
                toY = lowLevel;
            }

            // Determine color for VERTICAL line
            QColor verticalColor;
            if (hasCustomColor)
            {
                // Use custom color for vertical lines too
                verticalColor = customColor;
            }
            else
            {
                // No custom color - vertical lines use CYAN
                verticalColor = QColor(0x01, 0xFF, 0xFF); // Cyan
            }

            // Use currentLineWidth for vertical transitions too
            painter.setPen(QPen(verticalColor, currentLineWidth));
            painter.drawLine(currentX, fromY, currentX, toY);
        }

        prevTime = change.timestamp;
        prevValue = change.value;
        prevX = currentX;
    }

    // Draw the final segment
    QColor finalColor;

    bool finalIsX = (prevValue == "x" || prevValue == "X");
    bool finalIsZ = (prevValue == "z" || prevValue == "Z");

    // If user has chosen a custom color, use it for the final segment
    if (hasCustomColor)
    {
        finalColor = customColor;
    }
    else
    {
        // No custom color - use value-based color for final segment
        if (finalIsX)
        {
            finalColor = QColor(255, 0, 0); // Red for X
        }
        else if (finalIsZ)
        {
            finalColor = QColor(255, 165, 0); // Orange for Z
        }
        else if (prevValue == "0")
        {
            finalColor = QColor(0x01, 0xFF, 0xFF); // Cyan for 0
        }
        else if (prevValue == "1")
        {
            finalColor = QColor(0, 255, 0); // Green for 1
        }
        else
        {
            finalColor = QColor(0xFF, 0xE6, 0xCD); // Default for other values
        }
    }

    // Use currentLineWidth for the final segment
    painter.setPen(QPen(finalColor, currentLineWidth));

    int endX = timeToX(vcdParser->getEndTime());

    if (finalIsX || finalIsZ)
    {
        painter.drawLine(prevX, middleLevel, endX, middleLevel);
    }
    else if (prevValue == "1")
    {
        painter.drawLine(prevX, highLevel, endX, highLevel);
    }
    else
    {
        painter.drawLine(prevX, lowLevel, endX, lowLevel);
    }
}

void WaveformWidget::drawCleanTransition(QPainter &painter, int x, int top, int bottom, const QColor &signalColor)
{
    int height = bottom - top;

    // Draw thick vertical line (3 pixels wide for visibility)
    painter.setPen(QPen(signalColor, 2));
    painter.drawLine(x, top, x, bottom);

    // Draw crisp cross markers using integer coordinates
    int crossSize = 2;
    
    // Top cross - horizontal line
    painter.drawLine(x - crossSize, top + crossSize, x + crossSize, top + crossSize);
    // Top cross - vertical line
    painter.drawLine(x, top, x, top + crossSize * 2);
    
    // Bottom cross - horizontal line
    painter.drawLine(x - crossSize, bottom - crossSize, x + crossSize, bottom - crossSize);
    // Bottom cross - vertical line
    painter.drawLine(x, bottom - crossSize * 2, x, bottom);

    // Center dot - filled rectangle for crispness
    int centerY = top + height / 2;
    painter.fillRect(x - 1, centerY - 1, 3, 3, signalColor);
    
    // Optional: Add a white outline for better visibility
    painter.setPen(QPen(Qt::white, 1));
    painter.drawLine(x, top, x, bottom);
}

void WaveformWidget::drawBusWaveform(QPainter &painter, const VCDSignal &signal, int yPos)
{
    // Use lazy loading to get value changes
    const auto changes = vcdParser->getValueChangesForSignal(signal.fullName);
    if (changes.isEmpty())
        return;

        // Check if this signal is selected
    bool isSelected = false;
    for (int i = 0; i < displayItems.size(); i++) {
        if (selectedItems.contains(i) && 
            displayItems[i].type == DisplayItem::Signal && 
            displayItems[i].signal.signal.fullName == signal.fullName) {
            isSelected = true;
            break;
        }
    }

        int currentLineWidth = isSelected ? selectedLineWidth : lineWidth;


    // Emergency check for extreme zoom
    if (timeScale > 1000.0 || timeScale < 0.001)
    {
        qDebug() << "Emergency: Skipping bus drawing due to extreme zoom:" << timeScale;
        return;
    }

    // FIX: Use getSignalColor to get the color
    QColor signalColor = getSignalColor(signal.fullName);

    // USE EXACTLY THE SAME DIMENSIONS AS drawSignalWaveform
    int busTop = yPos + 3;                   // Same as signalTop
    int busBottom = yPos + signalHeight - 3; // Same as signalBottom
    int busMidY = yPos + signalHeight / 2;   // Same as signalMidY
    int textY = busMidY + 4;
    int waveformHeight = busBottom - busTop; // This should now be identical to signal waveform height

    int prevTime = 0;
    QString prevValue = getBusValueAtTime(signal.fullName, 0);
    int prevX = timeToX(prevTime);

    // Draw clean bus background - but make it the same visual thickness
    painter.fillRect(prevX, busTop, width() - signalNamesWidth - valuesColumnWidth, waveformHeight, QColor(0, 0, 0));

    // Draw value regions with clear transitions
    for (int i = 0; i < changes.size(); i++)
    {
        const auto &change = changes[i];
        int currentX = timeToX(change.timestamp);

        // Clean region coloring
        QColor regionColor = QColor(0, 0, 0);

        if (prevValue.contains('x') || prevValue.contains('X'))
        {
            regionColor = QColor(120, 60, 60); // Dark red for X
        }
        else if (prevValue.contains('z') || prevValue.contains('Z'))
        {
            regionColor = QColor(120, 80, 40); // Dark orange for Z
        }
        else if (!prevValue.isEmpty() && prevValue != "0")
        {
            // Active value - slightly brighter
            regionColor = QColor(0, 0, 0);
        }

        // Draw the value region - using same height as signals
        painter.fillRect(prevX, busTop, currentX - prevX, waveformHeight, regionColor);

        // Draw the value text with clean styling
        if (currentX - prevX > 50) // Only draw text if region is wide enough
        {
            QString displayValue = formatBusValue(prevValue);
            int textWidth = painter.fontMetrics().horizontalAdvance(displayValue);
            int centerX = prevX + (currentX - prevX) / 2;

            // Simple text with good contrast
            painter.setPen(QPen(Qt::cyan));
            painter.drawText(centerX - textWidth / 2, textY, displayValue);
        }

        // Draw clean transition line - using same line width as signals
        if (i > 0) // Don't draw transition for first value
        {
            drawCleanTransition(painter, currentX, busTop, busBottom, signalColor);
        }

        prevTime = change.timestamp;
        prevValue = change.value;
        prevX = currentX;
    }

    // Draw the final region
    int endX = timeToX(vcdParser->getEndTime());
    if (endX > prevX)
    {
        QColor finalRegionColor = QColor(0, 0, 0);
        if (prevValue.contains('x') || prevValue.contains('X'))
        {
            finalRegionColor = QColor(120, 60, 60);
        }
        else if (prevValue.contains('z') || prevValue.contains('Z'))
        {
            finalRegionColor = QColor(120, 80, 40);
        }

        painter.fillRect(prevX, busTop, endX - prevX, waveformHeight, finalRegionColor);

        if (endX - prevX > 50)
        {
            QString displayValue = formatBusValue(prevValue);
            int textWidth = painter.fontMetrics().horizontalAdvance(displayValue);
            int centerX = prevX + (endX - prevX) / 2;

            painter.setPen(QPen(Qt::cyan));
            painter.drawText(centerX - textWidth / 2, textY, displayValue);
        }
    }

// Draw clean bus outline - use currentLineWidth for selected signals
    painter.setPen(QPen(signalColor, currentLineWidth));
    painter.drawRect(timeToX(0), busTop, endX - timeToX(0), waveformHeight);
}

void WaveformWidget::updateScrollBar()
{
    if (!vcdParser)
    {
        horizontalScrollBar->setRange(0, 0);
        verticalScrollBar->setRange(0, 0);
        return;
    }

    // Calculate viewport dimensions safely
    int viewportWidth = width() - signalNamesWidth - valuesColumnWidth;
    if (viewportWidth < 10)
        viewportWidth = 10;

    int viewportHeight = height();
    if (viewportHeight < 10)
        viewportHeight = 10;

    // Horizontal scrolling (unchanged)
    const int LEFT_MARGIN_PIXELS = static_cast<int>(-10 * timeScale);
    const int RIGHT_MARGIN_PIXELS = static_cast<int>(100 * timeScale);
    int timelinePixelWidth = static_cast<int>(vcdParser->getEndTime() * timeScale);
    int totalPixelWidth = timelinePixelWidth + LEFT_MARGIN_PIXELS + RIGHT_MARGIN_PIXELS;
    int maxScrollOffset = qMax(0, totalPixelWidth - viewportWidth);

    horizontalScrollBar->setRange(0, maxScrollOffset);
    horizontalScrollBar->setPageStep(viewportWidth);
    horizontalScrollBar->setSingleStep(viewportWidth / 10);

    // Vertical scrolling - calculate total content height
    int totalHeight = calculateTotalHeight();
    int visibleHeight = height() - timeMarkersHeight; // Subtract pinned timeline

    // Only enable vertical scrollbar if content is taller than visible area
    if (totalHeight > visibleHeight)
    {
        int maxVerticalOffset = totalHeight - visibleHeight;
        verticalScrollBar->setRange(0, maxVerticalOffset);
        verticalScrollBar->setPageStep(visibleHeight);
        verticalScrollBar->setSingleStep(30);
        verticalScrollBar->setVisible(true);

        // Ensure current offset is within bounds
        if (verticalOffset > maxVerticalOffset)
        {
            verticalOffset = maxVerticalOffset;
            verticalScrollBar->setValue(verticalOffset);
        }
    }
    else
    {
        verticalScrollBar->setRange(0, 0);
        verticalScrollBar->setVisible(false);
        verticalOffset = 0;
    }

    qDebug() << "Scrollbar - Total height:" << totalHeight
             << "Visible height:" << visibleHeight
             << "Vertical offset:" << verticalOffset
             << "Max vertical:" << verticalScrollBar->maximum();
}

int WaveformWidget::calculateTotalHeight() const
{
    if (displayItems.isEmpty())
        return timeMarkersHeight; // Just the timeline area

    int totalHeight = topMargin + timeMarkersHeight;
    for (const auto &item : displayItems)
    {
        int itemHeight = (item.type == DisplayItem::Signal) ? signalHeight : 30;
        totalHeight += itemHeight;
    }

    // Add some extra padding at the bottom
    totalHeight += 10;

    return totalHeight;
}

int WaveformWidget::timeToX(int time) const
{
    if (!vcdParser)
        return 0;

    // Convert time to pixels, then subtract the scroll offset
    double pixelPosition = time * timeScale;
    double result = pixelPosition - timeOffset;

    // Clamp to safe integer range
    if (result > 1000000)
        return 1000000;
    if (result < -1000000)
        return -1000000;

    return static_cast<int>(result);
}

int WaveformWidget::xToTime(int x) const
{
    if (!vcdParser)
        return 0;

    // Handle invalid scale
    if (timeScale < 0.0001)
        return 0;

    // Convert pixel position (including scroll offset) back to time
    double result = (x + timeOffset) / timeScale;

    // Clamp to safe range
    if (result > 1000000000)
        return 1000000000;
    if (result < -1000000000)
        return -1000000000;

    return static_cast<int>(result);
}

QString WaveformWidget::getSignalValueAtTime(const QString &fullName, int time) const // CHANGE: parameter name
{
    // Use lazy loading - use fullName
    const auto changes = vcdParser->getValueChangesForSignal(fullName); // CHANGE: use fullName
    QString value = "0";

    for (const auto &change : changes)
    {
        if (change.timestamp > time)
            break;
        value = change.value;
    }

    return value;
}

QString WaveformWidget::getBusValueAtTime(const QString &fullName, int time) const // CHANGE: parameter name
{
    // Use lazy loading - use fullName
    const auto changes = vcdParser->getValueChangesForSignal(fullName); // CHANGE: use fullName
    QString value = "0";

    for (const auto &change : changes)
    {
        if (change.timestamp > time)
            break;
        value = change.value;
    }

    return value;
}

int WaveformWidget::calculateTimeStep(int startTime, int endTime) const
{
    int timeRange = endTime - startTime;
    if (timeRange <= 0)
        return 100;

    double pixelsPerStep = 100.0;
    double targetStep = pixelsPerStep / timeScale;

    double power = std::pow(10, std::floor(std::log10(targetStep)));
    double normalized = targetStep / power;

    if (normalized < 1.5)
        return static_cast<int>(power);
    else if (normalized < 3)
        return static_cast<int>(2 * power);
    else if (normalized < 7)
        return static_cast<int>(5 * power);
    else
        return static_cast<int>(10 * power);
}

void WaveformWidget::handleMultiSelection(int itemIndex, QMouseEvent *event)
{
    if (itemIndex < 0 || itemIndex >= displayItems.size())
        return;

    if (event->modifiers() & Qt::ShiftModifier && lastSelectedItem != -1)
    {
        // Shift-click: select range from last selected to current
        selectedItems.clear();
        int start = qMin(lastSelectedItem, itemIndex);
        int end = qMax(lastSelectedItem, itemIndex);
        for (int i = start; i <= end; i++)
        {
            selectedItems.insert(i);
        }
    }
    else if (event->modifiers() & Qt::ControlModifier)
    {
        // Ctrl-click: toggle selection
        if (selectedItems.contains(itemIndex))
        {
            selectedItems.remove(itemIndex);
        }
        else
        {
            selectedItems.insert(itemIndex);
        }
        lastSelectedItem = itemIndex;
    }
    else
    {
        // Regular click: single selection
        selectedItems.clear();
        selectedItems.insert(itemIndex);
        lastSelectedItem = itemIndex;
    }

    update();
    emit itemSelected(itemIndex);
}

int WaveformWidget::getItemYPosition(int index) const
{
    if (index < 0 || index >= displayItems.size())
        return -1;

    int yPos = timeMarkersHeight; // Start below the pinned timeline
    for (int i = 0; i < index; i++)
    {
        const auto &item = displayItems[i];
        int itemHeight = (item.type == DisplayItem::Signal) ? signalHeight : 30;
        yPos += itemHeight;
    }
    return yPos;
}

void WaveformWidget::startDrag(int itemIndex)
{
    if (itemIndex < 0 || itemIndex >= displayItems.size())
        return;

    isDraggingItem = true;
    dragItemIndex = itemIndex;
    dragStartPos = QCursor::pos();
    dragStartY = getItemYPosition(itemIndex) - verticalOffset; // Account for vertical offset
    setCursor(Qt::ClosedHandCursor);
}

void WaveformWidget::performDrag(int mouseY)
{
    if (!isDraggingItem || dragItemIndex < 0)
        return;

    // Adjust mouseY by vertical offset to get the actual position in the content
    int adjustedMouseY = mouseY + verticalOffset;

    int newIndex = -1;
    int currentY = topMargin + timeMarkersHeight;

    // Find new position based on adjusted mouse Y
    for (int i = 0; i < displayItems.size(); i++)
    {
        const auto &item = displayItems[i];
        int itemHeight = (item.type == DisplayItem::Signal) ? signalHeight : 30;

        // Check if mouse is within the first half of the item height (insert above)
        if (adjustedMouseY >= currentY && adjustedMouseY < currentY + itemHeight / 2)
        {
            newIndex = i;
            break;
        }
        // Check if mouse is within the second half of the item height (insert below)
        else if (adjustedMouseY >= currentY + itemHeight / 2 && adjustedMouseY < currentY + itemHeight)
        {
            newIndex = i + 1;
            break;
        }
        currentY += itemHeight;
    }

    // If we reached the end without finding a position, put it at the end
    if (newIndex == -1)
    {
        newIndex = displayItems.size();
    }

    // Clamp the new index to valid range
    newIndex = qMax(0, qMin(newIndex, displayItems.size()));

    // Don't move if it's the same position
    if (newIndex == dragItemIndex || newIndex == dragItemIndex + 1)
        return;

    moveItem(dragItemIndex, newIndex);
}

void WaveformWidget::moveItem(int itemIndex, int newIndex)
{
    // If moving to a position after the current item, adjust for the removal
    if (newIndex > itemIndex)
    {
        newIndex--;
    }

    DisplayItem item = displayItems[itemIndex];
    displayItems.removeAt(itemIndex);
    displayItems.insert(newIndex, item);

    // Update drag item index to the new position
    dragItemIndex = newIndex;

    // Update selection
    if (selectedItems.contains(itemIndex))
    {
        selectedItems.remove(itemIndex);
        selectedItems.insert(newIndex);
        lastSelectedItem = newIndex;
    }

    update();
}

void WaveformWidget::mousePressEvent(QMouseEvent *event)
{
    // Check if click is in search bar area (pinned)

    if (event->button() == Qt::LeftButton)
    {
        if (isOverNamesSplitter(event->pos()))
        {
            draggingNamesSplitter = true;
            setCursor(Qt::SplitHCursor);
            event->accept();
            return;
        }
        else if (isOverValuesSplitter(event->pos()))
        {
            draggingValuesSplitter = true;
            setCursor(Qt::SplitHCursor);
            event->accept();
            return;
        }
    }

    // Check if click is in timeline area (pinned top part of waveform area)
    int waveformStartX = signalNamesWidth + valuesColumnWidth;
    bool inTimelineArea = event->pos().x() >= waveformStartX &&
                          event->pos().y() < timeMarkersHeight;

    if (event->button() == Qt::LeftButton && inTimelineArea)
    {
        updateCursorTime(event->pos());
        event->accept();
        return;
    }

    // Check if click is in signal names column or waveform area
    bool inNamesColumn = event->pos().x() < signalNamesWidth;
    bool inWaveformArea = event->pos().x() >= waveformStartX;

    if (event->button() == Qt::MiddleButton)
    {
        // Start middle button drag for horizontal scrolling (waveform area only, excluding pinned timeline)
        if (!inNamesColumn && inWaveformArea && event->pos().y() >= timeMarkersHeight)
        {
            isDragging = true;
            dragStartX = event->pos().x() - waveformStartX;
            dragStartOffset = timeOffset;
            setCursor(Qt::ClosedHandCursor);
        }
    }
    else if (event->button() == Qt::LeftButton)
    {
        handleWaveformClick(event->pos());

        // Also allow setting cursor time when clicking in the main waveform area (excluding pinned timeline)
        if (inWaveformArea && event->pos().y() >= timeMarkersHeight)
        {
            updateCursorTime(event->pos());
            event->accept();
            return;
        }
        else if (!inNamesColumn && inWaveformArea)
        {
            // Start timeline dragging with left button
            isDragging = true;
            dragStartX = event->pos().x() - waveformStartX;
            dragStartOffset = timeOffset; // Current scroll position
            setCursor(Qt::ClosedHandCursor);
        }

        // Item selection/dragging only works in the scrollable area (below pinned headers)
        if (event->pos().y() >= topMargin + timeMarkersHeight)
        {
            int itemIndex = getItemAtPosition(event->pos());

            if (itemIndex >= 0)
            {
                // Handle multi-selection
                handleMultiSelection(itemIndex, event);

                // Prepare for drag - update visible signals first

                startDrag(itemIndex);
                update();
                emit itemSelected(itemIndex);
            }
            else 
            {
                // NEW: Clear selection when clicking empty space
                // Only clear if not using Ctrl or Shift modifiers (which are for multi-selection)
                if (!(event->modifiers() & (Qt::ControlModifier | Qt::ShiftModifier)))
                {
                    selectedItems.clear();
                    lastSelectedItem = -1;
                    update();
                    emit itemSelected(-1);
                }

                // Start timeline dragging with left button (waveform area only, excluding pinned timeline)
                isDragging = true;
                dragStartX = event->pos().x() - waveformStartX;
                dragStartOffset = timeOffset;
                setCursor(Qt::ClosedHandCursor);
            }
        }
        else
        {
            // NEW: Also clear selection when clicking in the pinned header area
            if (!(event->modifiers() & (Qt::ControlModifier | Qt::ShiftModifier)))
            {
                selectedItems.clear();
                lastSelectedItem = -1;
                update();
                emit itemSelected(-1);
            }
        }
    }
}

void WaveformWidget::mouseDoubleClickEvent(QMouseEvent *event)
{
    int itemIndex = getItemAtPosition(event->pos());
    if (itemIndex >= 0)
    {
        if (isSpaceItem(itemIndex))
        {
            renameItem(itemIndex);
            event->accept();
            return;
        }
    }
    QWidget::mouseDoubleClickEvent(event);
}

void WaveformWidget::mouseMoveEvent(QMouseEvent *event)
{
    if (draggingNamesSplitter)
    {
        signalNamesWidth = qMax(150, event->pos().x());
        updateSplitterPositions();
    }
    else if (draggingValuesSplitter)
    {
        valuesColumnWidth = qMax(80, event->pos().x() - signalNamesWidth);
        updateSplitterPositions();
    }
    else
    {
        // Update cursor when over splitter
        if (isOverNamesSplitter(event->pos()) || isOverValuesSplitter(event->pos()))
        {
            setCursor(Qt::SplitHCursor);
        }
        else
        {
            setCursor(Qt::ArrowCursor);
        }

        if (isDraggingItem)
        {
            performDrag(event->pos().y());

            update();
        }
        else if (isDragging)
        {
            int waveformStartX = signalNamesWidth + valuesColumnWidth;
            int delta = dragStartX - (event->pos().x() - waveformStartX);

            // Calculate new offset and clamp it to scrollbar range
            int newOffset = dragStartOffset + delta;
            int maxOffset = horizontalScrollBar->maximum();
            newOffset = qMax(0, qMin(newOffset, maxOffset));

            timeOffset = newOffset;

            // Update scrollbar position to match
            horizontalScrollBar->setValue(timeOffset);

            update();
        }

        // Emit time change for cursor position in waveform area
        int waveformStartX = signalNamesWidth + valuesColumnWidth;
        if (event->pos().x() >= waveformStartX)
        {
            int currentTime = xToTime(event->pos().x() - waveformStartX);
            emit timeChanged(currentTime);
        }
    }
}

void WaveformWidget::mouseReleaseEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton && (draggingNamesSplitter || draggingValuesSplitter))
    {
        draggingNamesSplitter = false;
        draggingValuesSplitter = false;
        setCursor(Qt::ArrowCursor);
        event->accept();
        return;
    }

    if (event->button() == Qt::MiddleButton || event->button() == Qt::LeftButton)
    {
        if (isDraggingItem)
        {
            isDraggingItem = false;
            dragItemIndex = -1;
            setCursor(Qt::ArrowCursor);
        }
        else if (isDragging)
        {
            isDragging = false;
            setCursor(Qt::ArrowCursor);
        }
    }
}

void WaveformWidget::keyPressEvent(QKeyEvent *event)
{
    if (event->key() == Qt::Key_A && event->modifiers() & Qt::ControlModifier)
    {
        selectAllSignals();
        event->accept();
    }
    else if (event->key() == Qt::Key_Delete)
    {
        removeSelectedSignals();
        event->accept();
    }
    else if (event->key() == Qt::Key_Escape && isSearchActive)
    {
        // Clear search on Escape and lose focus
        handleSearchInput("");
        isSearchFocused = false;
        event->accept();
    }
    else if (event->key() == Qt::Key_Return || event->key() == Qt::Key_Enter)
    {
        // Keep search but lose focus on Enter
        if (isSearchActive)
        {
            isSearchFocused = false;
            update();
            event->accept();
        }
        else
        {
            QWidget::keyPressEvent(event);
        }
    }
    else if (event->key() == Qt::Key_Backspace)
    {
        // Handle backspace in search
        if (isSearchActive)
        {
            handleSearchInput(searchText.left(searchText.length() - 1));
            event->accept();
        }
        else
        {
            QWidget::keyPressEvent(event);
        }
    }
    // Signal height adjustment shortcuts
    else if (event->modifiers() & Qt::ControlModifier)
    {
        if (event->key() == Qt::Key_Up)
        {
            setSignalHeight(signalHeight + 2);
            event->accept();
            return;
        }
        else if (event->key() == Qt::Key_Down)
        {
            setSignalHeight(signalHeight - 2);
            event->accept();
            return;
        }
    }
    else if (!event->text().isEmpty() && event->text().at(0).isPrint())
    {
        // Handle regular text input for search
        if (!isSearchActive)
        {
            handleSearchInput(event->text());
        }
        else
        {
            handleSearchInput(searchText + event->text());
        }
        event->accept();
    }
    else
    {
        QWidget::keyPressEvent(event);
    }
}

void WaveformWidget::wheelEvent(QWheelEvent *event)
{
    if (event->modifiers() & Qt::ControlModifier)
    {
        // Ctrl + Wheel for zoom
        if (event->angleDelta().y() > 0)
        {
            zoomIn();
        }
        else
        {
            zoomOut();
        }
    }
    else if (event->modifiers() & Qt::ShiftModifier)
    {
        // Shift + Wheel for horizontal scrolling
        int scrollAmount = event->angleDelta().y();
        timeOffset += scrollAmount / 2;
        updateScrollBar();
        update();
    }
    else
    {
        // Regular wheel for vertical scrolling
        int scrollAmount = event->angleDelta().y();
        verticalOffset -= scrollAmount / 2;

        // Clamp vertical offset to valid range
        int maxVerticalOffset = verticalScrollBar->maximum();
        verticalOffset = qMax(0, qMin(verticalOffset, maxVerticalOffset));

        // Update scrollbar position
        verticalScrollBar->setValue(verticalOffset);

        update();

        qDebug() << "Vertical scroll - Offset:" << verticalOffset << "Max:" << maxVerticalOffset;
    }
}

void WaveformWidget::setVisibleSignals(const QList<VCDSignal> &visibleSignals)
{
    // If we're at an extreme zoom level, reset to reasonable zoom first
    if (timeScale > 100.0 || timeScale < 0.01)
    {
        qDebug() << "Resetting extreme zoom level before adding signals:" << timeScale;
        timeScale = 1.0;
        timeOffset = 0;
    }

    displayItems.clear();

    // Load data for the selected signals
    if (vcdParser && !visibleSignals.isEmpty())
    {
        QList<QString> fullNames; // CHANGE: use fullNames
        for (const auto &signal : visibleSignals)
        {
            fullNames.append(signal.fullName); // CHANGE: use fullName
        }

        // Load signal data before displaying
        vcdParser->loadSignalsData(fullNames); // This now uses fullNames
    }

    for (const auto &signal : visibleSignals)
    {
        displayItems.append(DisplayItem::createSignal(signal));
    }
    selectedItems.clear();
    lastSelectedItem = -1;

    // Auto-zoom to fit after adding signals
    if (!visibleSignals.isEmpty())
    {
        zoomFit();
    }

    updateScrollBar();
    update();
    emit itemSelected(-1);
}

// Update WaveformWidget::contextMenuEvent to handle waveform area context menus
void WaveformWidget::contextMenuEvent(QContextMenuEvent *event)
{
    int itemIndex = getItemAtPosition(event->pos());
    
    // If no item clicked but we're in waveform area, try to find signal under cursor
    if (itemIndex == -1) {
        int waveformStartX = signalNamesWidth + valuesColumnWidth;
        QPoint adjustedPos = event->pos();
        adjustedPos.setX(adjustedPos.x() - waveformStartX);
        itemIndex = getItemAtPosition(adjustedPos);
    }
    
    showContextMenu(event->globalPos(), itemIndex);
}

void WaveformWidget::resizeEvent(QResizeEvent *event)
{
    Q_UNUSED(event)

    // Ensure minimum dimensions
    if (width() < 100 || height() < 100)
    {
        qDebug() << "Warning: Very small widget size" << width() << "x" << height();
    }

    updateScrollBar();

    // Position the scrollbars safely
    int scrollbarSize = 20;

    // Horizontal scrollbar - spans the entire bottom
    horizontalScrollBar->setGeometry(
        signalNamesWidth + valuesColumnWidth,
        qMax(0, height() - scrollbarSize),
        qMax(0, width() - signalNamesWidth - valuesColumnWidth),
        scrollbarSize);

    // Vertical scrollbar - spans the right side, above horizontal scrollbar
    verticalScrollBar->setGeometry(
        qMax(0, width() - scrollbarSize),
        0,
        scrollbarSize,
        qMax(0, height() - scrollbarSize)); // Leave space for horizontal scrollbar

    qDebug() << "Resize event - Widget:" << width() << "x" << height()
             << "Horizontal scrollbar:" << horizontalScrollBar->geometry()
             << "Vertical scrollbar:" << verticalScrollBar->geometry();
}

int WaveformWidget::getItemAtPosition(const QPoint &pos) const
{
    if (displayItems.isEmpty())
        return -1;

    // Only detect items in the scrollable area (below pinned headers)
    if (pos.y() < timeMarkersHeight)
        return -1;

    // FIXED: Adjust for vertical offset correctly
    int y = pos.y() + verticalOffset - timeMarkersHeight;

    if (y < 0)
        return -1;

    int currentY = 0;
    for (int i = 0; i < displayItems.size(); i++)
    {
        const auto &item = displayItems[i];
        int itemHeight = (item.type == DisplayItem::Signal) ? signalHeight : 30;

        if (y >= currentY && y < currentY + itemHeight)
            return i;
        currentY += itemHeight;
    }

    return -1;
}

QString WaveformWidget::promptForName(const QString &title, const QString &defaultName)
{
    bool ok;
    QString name = QInputDialog::getText(this, title, "Name:", QLineEdit::Normal, defaultName, &ok);
    if (ok)
    {
        return name;
    }
    return defaultName;
}

void WaveformWidget::addSpaceAbove(int index)
{
    if (index < 0 || index >= displayItems.size())
        return;

    QString name = promptForName("Add Space", "");
    displayItems.insert(index, DisplayItem::createSpace(name));
    update();
}

void WaveformWidget::addSpaceBelow(int index)
{
    if (index < 0 || index >= displayItems.size())
        return;

    QString name = promptForName("Add Space", "");
    int insertIndex = index + 1;
    if (insertIndex > displayItems.size())
    {
        insertIndex = displayItems.size();
    }

    displayItems.insert(insertIndex, DisplayItem::createSpace(name));
    update();
}

void WaveformWidget::renameItem(int itemIndex)
{
    if (itemIndex < 0 || itemIndex >= displayItems.size())
        return;

    DisplayItem &item = displayItems[itemIndex];
    QString currentName = item.getName();
    QString newName = promptForName("Rename", currentName);

    if (!newName.isEmpty() && newName != currentName && item.type == DisplayItem::Space)
    {
        item.space.name = newName;
        update();
    }
}

QColor WaveformWidget::getSignalColor(const QString &fullName) const
{
    // If user has set a custom color, use it
    if (signalColors.contains(fullName))
    {
        return signalColors[fullName];
    }

    // Default to #ffe6cd for all signals (this will be overridden for 0 and 1 values)
    return QColor(0xFF, 0xE6, 0xCD);
}

void WaveformWidget::changeSignalColor(int itemIndex)
{
    if (selectedItems.isEmpty())
        return;

    // Get the first selected signal to use as current color reference
    QColor currentColor = Qt::green;
    for (int index : selectedItems)
    {
        if (isSignalItem(index))
        {
            const VCDSignal &signal = displayItems[index].signal.signal;
            currentColor = getSignalColor(signal.fullName);
            break;
        }
    }

    QMenu colorMenu(this);

    // Predefined colors
    QList<QPair<QString, QColor>> predefinedColors = {
        {"Red", QColor(255, 0, 0)},
        {"Green", QColor(0, 255, 0)},
        {"Blue", QColor(0, 0, 255)},
        {"Yellow", QColor(255, 255, 0)},
        {"Cyan", QColor(0, 255, 255)},
        {"Magenta", QColor(255, 0, 255)},
        {"Orange", QColor(255, 165, 0)},
        {"Purple", QColor(128, 0, 128)},
        {"Pink", QColor(255, 192, 203)},
        {"White", QColor(255, 255, 255)}};

    for (const auto &colorPair : predefinedColors)
    {
        QAction *colorAction = colorMenu.addAction(colorPair.first);
        colorAction->setData(colorPair.second);

        // Create color icon
        QPixmap pixmap(16, 16);
        pixmap.fill(colorPair.second);
        colorAction->setIcon(QIcon(pixmap));
    }

    colorMenu.addSeparator();
    colorMenu.addAction("Custom Color...");

    // Update menu title to show how many signals are selected
    if (selectedItems.size() > 1)
    {
        colorMenu.setTitle(QString("Change Color for %1 Signals").arg(selectedItems.size()));
    }

    QAction *selectedAction = colorMenu.exec(QCursor::pos());

    if (selectedAction)
    {
        QColor newColor;

        if (selectedAction->text() == "Custom Color...")
        {
            newColor = QColorDialog::getColor(currentColor, this,
                                              QString("Choose color for %1 signals").arg(selectedItems.size()));
            if (!newColor.isValid())
            {
                return; // User cancelled
            }
        }
        else
        {
            newColor = selectedAction->data().value<QColor>();
        }

        // Apply the color to all selected signals using fullName
        for (int index : selectedItems)
        {
            if (isSignalItem(index))
            {
                const VCDSignal &signal = displayItems[index].signal.signal;
                signalColors[signal.fullName] = newColor;
            }
        }
        update();
    }
}

bool WaveformWidget::isOverNamesSplitter(const QPoint &pos) const
{
    return (pos.x() >= signalNamesWidth - 3 && pos.x() <= signalNamesWidth + 3);
}

bool WaveformWidget::isOverValuesSplitter(const QPoint &pos) const
{
    int valuesColumnStart = signalNamesWidth;
    int valuesColumnEnd = valuesColumnStart + valuesColumnWidth;
    return (pos.x() >= valuesColumnEnd - 3 && pos.x() <= valuesColumnEnd + 3);
}

void WaveformWidget::updateSplitterPositions()
{
    // Ensure minimum widths
    signalNamesWidth = qMax(150, signalNamesWidth);
    valuesColumnWidth = qMax(80, valuesColumnWidth);

    // Ensure maximum widths
    if (signalNamesWidth + valuesColumnWidth > width() - 300)
    {
        valuesColumnWidth = width() - 300 - signalNamesWidth;
    }

    update();
}


void WaveformWidget::resetNavigationForCurrentSignal()
{
    if (currentlyNavigatedSignal.isEmpty())
        return;
        
    // Update the current index based on cursor position
    int newIndex = findEventIndexForTime(cursorTime, currentlyNavigatedSignal);
    signalCurrentEventIndex[currentlyNavigatedSignal] = newIndex;
    currentEventIndex = newIndex;
    
    qDebug() << "Reset navigation: Signal" << currentlyNavigatedSignal 
             << "Cursor time:" << cursorTime 
             << "New index:" << newIndex;
}

void WaveformWidget::updateCursorTime(const QPoint &pos)
{
    int waveformStartX = signalNamesWidth + valuesColumnWidth;

    // Only set cursor if click is in the timeline area (top part) AND we have signals
    if ((pos.x() < waveformStartX || pos.y() >= timeMarkersHeight) || displayItems.isEmpty())
    {
        return;
    }

    // Calculate cursor time based on the visible waveform area, accounting for horizontal scrolling
    int clickXInWaveform = pos.x() - waveformStartX;

    // Convert the click position to time, accounting for current zoom and scroll
    int oldCursorTime = cursorTime;
    cursorTime = xToTime(clickXInWaveform);

    showCursor = true;
    
    // Reset navigation for current signal when cursor moves
    if (!currentlyNavigatedSignal.isEmpty()) {
        resetNavigationForCurrentSignal();
    }
    
    // Emit cursor time change if it actually changed
    if (cursorTime != oldCursorTime) {
        emit cursorTimeChanged(cursorTime);
    }
    
    update();
}

void WaveformWidget::showContextMenu(const QPoint &pos, int itemIndex)
{
    QMenu contextMenu(this);

    if (itemIndex >= 0)
    {
        // Ensure the clicked item is selected if no multi-selection
        if (!selectedItems.contains(itemIndex) && selectedItems.size() <= 1)
        {
            selectedItems.clear();
            selectedItems.insert(itemIndex);
            lastSelectedItem = itemIndex;
            update();
        }

        // Remove option - show count if multiple selected
        QString removeText = "Remove";
        if (selectedItems.size() > 1)
        {
            removeText = QString("Remove %1 Signals").arg(selectedItems.size());
        }
        else if (isSignalItem(itemIndex))
        {
            removeText = "Remove Signal";
        }
        else if (isSpaceItem(itemIndex))
        {
            removeText = "Remove Space";
        }

        contextMenu.addAction(removeText, this, &WaveformWidget::removeSelectedSignals);
        contextMenu.addSeparator();

        // Color change for signals - show count if multiple selected
        bool hasSignals = false;
        for (int index : selectedItems)
        {
            if (isSignalItem(index))
            {
                hasSignals = true;
                break;
            }
        }

        if (hasSignals)
        {
            QString colorText = "Change Color";
            if (selectedItems.size() > 1)
            {
                colorText = QString("Change Color for %1 Signals").arg(selectedItems.size());
            }
            contextMenu.addAction(colorText, this, [this, itemIndex]()
                                  { changeSignalColor(itemIndex); });
            contextMenu.addSeparator();
        }

        // Rename for spaces (only if single space selected)
        if (isSpaceItem(itemIndex) && selectedItems.size() == 1)
        {
            contextMenu.addAction("Rename", this, [this, itemIndex]()
                                  { renameItem(itemIndex); });
            contextMenu.addSeparator();
        }

        // Bus display options (only show if any multi-bit signals are selected)
        bool hasMultiBitSignals = false;
        for (int index : selectedItems)
        {
            if (isSignalItem(index) && getSignalFromItem(index).width > 1)
            {
                hasMultiBitSignals = true;
                break;
            }
        }

        if (hasMultiBitSignals)
        {
            QMenu *busFormatMenu = contextMenu.addMenu("Bus Display Format");

            QAction *hexAction = busFormatMenu->addAction("Hexadecimal", [this]()
                                                          { setBusDisplayFormat(WaveformWidget::Hex); });
            QAction *binAction = busFormatMenu->addAction("Binary", [this]()
                                                          { setBusDisplayFormat(WaveformWidget::Binary); });
            QAction *octAction = busFormatMenu->addAction("Octal", [this]()
                                                          { setBusDisplayFormat(WaveformWidget::Octal); });
            QAction *decAction = busFormatMenu->addAction("Decimal", [this]()
                                                          { setBusDisplayFormat(WaveformWidget::Decimal); });

            hexAction->setCheckable(true);
            binAction->setCheckable(true);
            octAction->setCheckable(true);
            decAction->setCheckable(true);

            hexAction->setChecked(busDisplayFormat == Hex);
            binAction->setChecked(busDisplayFormat == Binary);
            octAction->setChecked(busDisplayFormat == Octal);
            decAction->setChecked(busDisplayFormat == Decimal);

            contextMenu.addSeparator();
        }

        // Space management
        contextMenu.addAction("Add Space Above", this, [this, itemIndex]()
                              { addSpaceAbove(itemIndex); });
        contextMenu.addAction("Add Space Below", this, [this, itemIndex]()
                              { addSpaceBelow(itemIndex); });
    }
    else
    {
        // Global bus display options when clicking empty space
        QMenu *busFormatMenu = contextMenu.addMenu("Bus Display Format");

        QAction *hexAction = busFormatMenu->addAction("Hexadecimal", [this]()
                                                      { setBusDisplayFormat(WaveformWidget::Hex); });
        QAction *binAction = busFormatMenu->addAction("Binary", [this]()
                                                      { setBusDisplayFormat(WaveformWidget::Binary); });
        QAction *octAction = busFormatMenu->addAction("Octal", [this]()
                                                      { setBusDisplayFormat(WaveformWidget::Octal); });
        QAction *decAction = busFormatMenu->addAction("Decimal", [this]()
                                                      { setBusDisplayFormat(WaveformWidget::Decimal); });

        hexAction->setCheckable(true);
        binAction->setCheckable(true);
        octAction->setCheckable(true);
        decAction->setCheckable(true);

        hexAction->setChecked(busDisplayFormat == Hex);
        binAction->setChecked(busDisplayFormat == Binary);
        octAction->setChecked(busDisplayFormat == Octal);
        decAction->setChecked(busDisplayFormat == Decimal);
    }

    QAction *selectedAction = contextMenu.exec(pos);
    if (!selectedAction && itemIndex >= 0 && selectedItems.size() <= 1)
    {
        // Restore selection if menu was cancelled and only single item was selected
        selectedItems.clear();
        selectedItems.insert(itemIndex);
        update();
    }

    emit contextMenuRequested(pos, itemIndex);
}

QString WaveformWidget::formatBusValue(const QString &binaryValue) const
{
    if (binaryValue.isEmpty())
        return "x";

    // Handle special cases
    if (binaryValue == "x" || binaryValue == "X")
        return "x";
    if (binaryValue == "z" || binaryValue == "Z")
        return "z";

    // Check if it's a valid binary string
    if (!isValidBinary(binaryValue))
    {
        return binaryValue; // Return as-is if not pure binary
    }

    switch (busDisplayFormat)
    {
    case Hex:
        return binaryToHex(binaryValue);
    case Binary:
        return binaryValue;
    case Octal:
        return binaryToOctal(binaryValue);
    case Decimal:
        return binaryToDecimal(binaryValue);
    default:
        return binaryToHex(binaryValue);
    }
}

bool WaveformWidget::isValidBinary(const QString &value) const
{
    for (QChar ch : value)
    {
        if (ch != '0' && ch != '1')
        {
            return false;
        }
    }
    return true;
}

QString WaveformWidget::binaryToHex(const QString &binaryValue) const
{
    if (binaryValue.isEmpty())
        return "0";

    // Convert binary string to integer
    bool ok;
    unsigned long long value = binaryValue.toULongLong(&ok, 2);

    if (!ok)
    {
        return "x"; // Conversion failed
    }

    // Calculate number of hex digits needed
    int bitCount = binaryValue.length();
    int hexDigits = (bitCount + 3) / 4; // ceil(bitCount / 4)

    // Format as hex with appropriate number of digits
    return "0x" + QString::number(value, 16).rightJustified(hexDigits, '0').toUpper();
}

QString WaveformWidget::binaryToOctal(const QString &binaryValue) const
{
    if (binaryValue.isEmpty())
        return "0";

    // Convert binary to octal
    QString octal;
    QString paddedBinary = binaryValue;

    // Pad with zeros to make length multiple of 3
    while (paddedBinary.length() % 3 != 0)
    {
        paddedBinary = "0" + paddedBinary;
    }

    for (int i = 0; i < paddedBinary.length(); i += 3)
    {
        QString chunk = paddedBinary.mid(i, 3);
        int decimal = chunk.toInt(nullptr, 2);
        octal += QString::number(decimal);
    }

    return "0" + octal;
}

QString WaveformWidget::binaryToDecimal(const QString &binaryValue) const
{
    if (binaryValue.isEmpty())
        return "0";

    bool ok;
    unsigned long long value = binaryValue.toULongLong(&ok, 2);

    if (!ok)
    {
        return "x"; // Conversion failed
    }

    return QString::number(value);
}

void WaveformWidget::drawSearchBar(QPainter &painter)
{
    int searchBarHeight = 25;

    // Draw search bar background with focus indication
    QColor searchBgColor = isSearchFocused ? QColor(90, 90, 100) : QColor(70, 70, 80);
    painter.fillRect(0, timeMarkersHeight, signalNamesWidth, searchBarHeight, searchBgColor);

    // Draw border when focused
    if (isSearchFocused)
    {
        painter.setPen(QPen(QColor(100, 150, 255), 2));
        painter.drawRect(1, timeMarkersHeight + 1, signalNamesWidth - 2, searchBarHeight - 2);
    }

    // Draw search icon or label
    painter.setPen(QPen(Qt::white));
    painter.drawText(5, timeMarkersHeight + searchBarHeight - 8, "🔍");

    // Draw search text with cursor
    if (searchText.isEmpty())
    {
        painter.setPen(QPen(QColor(180, 180, 180)));
        painter.drawText(25, timeMarkersHeight + searchBarHeight - 8, "Search signals...");
    }
    else
    {
        painter.setPen(QPen(Qt::white));
        painter.drawText(25, timeMarkersHeight + searchBarHeight - 8, searchText);

        // Draw blinking cursor when focused (optional)
        if (isSearchFocused)
        {
            int textWidth = painter.fontMetrics().horizontalAdvance(searchText);
            int cursorX = 25 + textWidth + 2;
            painter.drawLine(cursorX, timeMarkersHeight + 5, cursorX, timeMarkersHeight + searchBarHeight - 5);
        }

        // Draw result count
        if (!searchResults.isEmpty())
        {
            QString resultText = QString("(%1)").arg(searchResults.size());
            int textWidth = painter.fontMetrics().horizontalAdvance(resultText);
            painter.drawText(signalNamesWidth - textWidth - 5, timeMarkersHeight + searchBarHeight - 8, resultText);
        }
    }

    // Update top margin to account for search bar
    // topMargin = searchBarHeight;
}

void WaveformWidget::searchSignals(const QString &searchText)
{
    handleSearchInput(searchText);
}

void WaveformWidget::clearSearch()
{
    handleSearchInput("");
}

void WaveformWidget::handleSearchInput(const QString &text)
{
    searchText = text;
    isSearchActive = !searchText.isEmpty();
    updateSearchResults();
    update();
}

void WaveformWidget::updateSearchResults()
{
    searchResults.clear();

    if (!isSearchActive || searchText.isEmpty())
    {
        // If no search, show all signals
        for (int i = 0; i < displayItems.size(); i++)
        {
            if (displayItems[i].type == DisplayItem::Signal)
            {
                searchResults.insert(i);
            }
        }
    }
    else
    {
        // Filter signals based on search text
        QString searchLower = searchText.toLower();
        for (int i = 0; i < displayItems.size(); i++)
        {
            if (displayItems[i].type == DisplayItem::Signal)
            {
                QString signalName = displayItems[i].getFullPath().toLower();
                if (signalName.contains(searchLower))
                {
                    searchResults.insert(i);
                }
            }
        }
    }

    // qDebug() << "Search results:" << searchResults;
    applySearchFilter();
}

void WaveformWidget::applySearchFilter()
{
    if (isSearchActive)
    {
        // Only select search results, don't filter them out
        selectedItems = searchResults;
        if (!selectedItems.isEmpty())
        {
            lastSelectedItem = *selectedItems.begin();
        }
        else
        {
            lastSelectedItem = -1;
        }
    }
    else
    {
        // Clear selection when search is inactive
        selectedItems.clear();
        lastSelectedItem = -1;
    }
    update();
    emit itemSelected(lastSelectedItem);
}

// Update the signal loading functions to use fullName
void WaveformWidget::ensureSignalLoaded(const QString &fullName) // CHANGE: parameter name
{
    if (!loadedSignalIdentifiers.contains(fullName)) // CHANGE: use fullName
    {
        // Load the signal data
        QList<QString> signalsToLoad = {fullName};
        vcdParser->loadSignalsData(signalsToLoad);
        loadedSignalIdentifiers.insert(fullName); // CHANGE: use fullName

        // Manage cache size
        if (loadedSignalIdentifiers.size() > MAX_CACHED_SIGNALS)
        {
            // Remove least recently used signal
            if (!loadedSignalIdentifiers.isEmpty())
            {
                QString oldestSignal = *loadedSignalIdentifiers.begin();
                loadedSignalIdentifiers.remove(oldestSignal);
            }
        }
    }
}


void WaveformWidget::setNavigationMode(NavigationMode mode)
{
    navigationMode = mode;
    
    // Clear ALL cached events when navigation mode changes
    signalEventTimestamps.clear();
    signalCurrentEventIndex.clear();
    currentlyNavigatedSignal.clear();
    currentEventIndex = -1;
    
    // Force update events immediately when mode changes
    if (!selectedItems.isEmpty()) {
        updateEventList();
    }
    
    // Emit signal to update button states
    emit timeChanged(cursorTime);
}

void WaveformWidget::navigateToTime(int targetTime)
{
    if (!vcdParser) return;
    
    // Ensure the time is within valid range
    int endTime = vcdParser->getEndTime();
    targetTime = qMax(0, qMin(targetTime, endTime));
    
    int oldCursorTime = cursorTime;
    
    // Set cursor time
    cursorTime = targetTime;
    showCursor = true;
    
    // Center the view on the target time
    int viewportWidth = width() - signalNamesWidth - valuesColumnWidth;
    int targetX = timeToX(targetTime);
    timeOffset = qMax(0, targetX - viewportWidth / 2);
    
    // Reset navigation for current signal
    if (!currentlyNavigatedSignal.isEmpty()) {
        resetNavigationForCurrentSignal();
    }
    
    // Emit cursor time change if it actually changed
    if (cursorTime != oldCursorTime) {
        emit cursorTimeChanged(cursorTime);  // ADD THIS LINE
    }
    
    updateScrollBar();
    update();
}


void WaveformWidget::navigateToPreviousEvent()
{
    qDebug() << "=== PREVIOUS BUTTON CLICKED ===";
    
    if (currentlyNavigatedSignal.isEmpty() || !signalEventTimestamps.contains(currentlyNavigatedSignal))
        return;

    QVector<int>& events = signalEventTimestamps[currentlyNavigatedSignal];
    int& currentIndex = signalCurrentEventIndex[currentlyNavigatedSignal];
    
    if (events.isEmpty())
        return;

    // If no current index set, find where we are based on cursor time
    if (currentIndex == -1) {
        currentIndex = findEventIndexForTime(cursorTime, currentlyNavigatedSignal);
        qDebug() << "Setting initial current index to:" << currentIndex;
    }
    
    // If we're before the first event, go to the first event
    if (currentIndex == -1) {
        currentIndex = 0;
        int targetTime = events[currentIndex];
        currentEventIndex = currentIndex;

        qDebug() << "Previous: Before first event, going to first event at index" << currentIndex << "Time:" << targetTime;
        navigateToTime(targetTime);
        return;
    }
    
    // If we're at the beginning, don't move
    if (currentIndex <= 0)
        return;

    currentIndex--;
    int targetTime = events[currentIndex];
    currentEventIndex = currentIndex;

    qDebug() << "Previous: Index" << currentIndex << "Time:" << targetTime;
    navigateToTime(targetTime);
}

void WaveformWidget::navigateToNextEvent()
{
    qDebug() << "=== NEXT BUTTON CLICKED ===";
    
    if (currentlyNavigatedSignal.isEmpty() || !signalEventTimestamps.contains(currentlyNavigatedSignal))
        return;

    QVector<int>& events = signalEventTimestamps[currentlyNavigatedSignal];
    int& currentIndex = signalCurrentEventIndex[currentlyNavigatedSignal];
    
    if (events.isEmpty())
        return;

    // If no current index set, find where we are based on cursor time
    if (currentIndex == -1) {
        currentIndex = findEventIndexForTime(cursorTime, currentlyNavigatedSignal);
        qDebug() << "Setting initial current index to:" << currentIndex;
    }
    
    // If we're before the first event, go to the first event
    if (currentIndex == -1) {
        currentIndex = 0;
        int targetTime = events[currentIndex];
        currentEventIndex = currentIndex;

        qDebug() << "Next: Before first event, going to first event at index" << currentIndex << "Time:" << targetTime;
        navigateToTime(targetTime);
        return;
    }
    
    // If we're at the end, don't move
    if (currentIndex >= events.size() - 1)
        return;

    currentIndex++;
    int targetTime = events[currentIndex];
    currentEventIndex = currentIndex;

    qDebug() << "Next: Index" << currentIndex << "Time:" << targetTime;
    navigateToTime(targetTime);
}

bool WaveformWidget::hasPreviousEvent() const
{
    if (currentlyNavigatedSignal.isEmpty() || !signalEventTimestamps.contains(currentlyNavigatedSignal))
        return false;
        
    const QVector<int>& events = signalEventTimestamps[currentlyNavigatedSignal];
    int currentIndex = signalCurrentEventIndex.value(currentlyNavigatedSignal, -1);
    
    if (events.isEmpty())
        return false;
    
    // If we're before the first event, no previous available
    if (currentIndex == -1) {
        return false;
    }
    
    // If we're at the first event but there are multiple events, we can go to previous (which would be before first)
    // OR if we're after the first event, we can go to previous event
    return currentIndex > 0;
}

bool WaveformWidget::hasNextEvent() const
{
    if (currentlyNavigatedSignal.isEmpty() || !signalEventTimestamps.contains(currentlyNavigatedSignal))
        return false;
        
    const QVector<int>& events = signalEventTimestamps[currentlyNavigatedSignal];
    int currentIndex = signalCurrentEventIndex.value(currentlyNavigatedSignal, -1);
    
    if (events.isEmpty())
        return false;
    
    // If we're before the first event, we can go to the first event
    if (currentIndex == -1) {
        return true;
    }
    
    // If we're at or before the last event, we can go next
    return currentIndex < events.size() - 1;
}

void WaveformWidget::updateEventList()
{
    if (selectedItems.isEmpty() || !vcdParser)
        return;

    // Get the first selected signal for navigation
    int selectedIndex = *selectedItems.begin();
    if (!isSignalItem(selectedIndex))
        return;

    const VCDSignal &signal = getSignalFromItem(selectedIndex);
    
    // Store which signal we're navigating
    currentlyNavigatedSignal = signal.fullName;
    
    const auto changes = vcdParser->getValueChangesForSignal(signal.fullName);
    if (changes.isEmpty())
        return;

    // Always recompute events to ensure they're up to date
    QVector<int> events;
    
    QString prevValue;
    
    qDebug() << "=== PROCESSING EVENTS FOR MODE:" << navigationMode << "===";
    
    for (int i = 0; i < changes.size(); i++)
    {
        const auto &change = changes[i];
        bool includeEvent = false;

        switch (navigationMode)
        {
        case ValueChange:
            includeEvent = true;
            qDebug() << "  ValueChange: including time" << change.timestamp << "value:" << change.value;
            break;

        case SignalRise:
            if (i > 0) {
                includeEvent = (prevValue == "0" && change.value == "1");
                if (includeEvent) {
                    qDebug() << "  SignalRise: including time" << change.timestamp << "prev:" << prevValue << "curr:" << change.value;
                }
            }
            break;

        case SignalFall:
            if (i > 0) {
                includeEvent = (prevValue == "1" && change.value == "0");
                if (includeEvent) {
                    qDebug() << "  SignalFall: including time" << change.timestamp << "prev:" << prevValue << "curr:" << change.value;
                }
            }
            break;
        
        }

        if (includeEvent)
        {
            events.append(change.timestamp);
        }

        prevValue = change.value;
    }

    // Store events for this signal
    signalEventTimestamps[signal.fullName] = events;
    
    // Set current index based on cursor position for this signal
    int newIndex = findEventIndexForTime(cursorTime, signal.fullName);
    signalCurrentEventIndex[signal.fullName] = newIndex;
    currentEventIndex = newIndex;
    
    qDebug() << "=== NAVIGATION SUMMARY ===";
    qDebug() << "Signal:" << signal.fullName;
    qDebug() << "Mode:" << navigationMode;
    qDebug() << "Total changes:" << changes.size();
    qDebug() << "Navigation events found:" << events.size();
    qDebug() << "Cursor time:" << cursorTime;
    qDebug() << "Current index:" << newIndex;
    qDebug() << "Events list:" << events;
    qDebug() << "Button states - HasPrev:" << hasPreviousEvent() << "HasNext:" << hasNextEvent();
    qDebug() << "=== END SUMMARY ===";
}

void WaveformWidget::forceNavigationUpdate()
{
    // Clear all navigation state
    signalEventTimestamps.clear();
    signalCurrentEventIndex.clear();
    currentlyNavigatedSignal.clear();
    currentEventIndex = -1;
    
    // Force update if we have selected signals
    if (!selectedItems.isEmpty()) {
        updateEventList();
    }
    
    update();
    emit timeChanged(cursorTime);
}

int WaveformWidget::findEventIndexForTime(int time, const QString& signalFullName) const
{
    if (!signalEventTimestamps.contains(signalFullName))
        return -1;
        
    const QVector<int>& events = signalEventTimestamps[signalFullName];
    
    if (events.isEmpty())
        return -1;
    
    // If we're before the first event, return -1 to indicate we're before any event
    if (time < events.first()) {
        return -1;
    }
    
    // If we're after the last event, return the last event index
    if (time > events.last()) {
        return events.size() - 1;
    }
    
    // Find the event that is closest to but not greater than the current time
    for (int i = events.size() - 1; i >= 0; i--) {
        if (events[i] <= time) {
            return i;
        }
    }
    
    // Should never reach here, but return -1 if we do
    return -1;
}

// Overload for currently navigated signal
int WaveformWidget::findEventIndexForTime(int time) const
{
    if (currentlyNavigatedSignal.isEmpty())
        return -1;
    return findEventIndexForTime(time, currentlyNavigatedSignal);
}

int WaveformWidget::getCurrentEventTime() const
{
    if (currentEventIndex >= 0 && currentEventIndex < eventTimestamps.size())
    {
        return eventTimestamps[currentEventIndex];
    }
    return cursorTime;
}

void WaveformWidget::selectSignalAtPosition(const QPoint &pos)
{
    int itemIndex = getItemAtPosition(pos);
    if (itemIndex >= 0 && isSignalItem(itemIndex))
    {
        // Single selection - clear previous selection unless using modifiers
        Qt::KeyboardModifiers modifiers = QApplication::keyboardModifiers();
        if (!(modifiers & (Qt::ControlModifier | Qt::ShiftModifier)))
        {
            selectedItems.clear();
        }
        selectedItems.insert(itemIndex);
        lastSelectedItem = itemIndex;

        // Force navigation update for the newly selected signal
        forceNavigationUpdate();

        update();
        emit itemSelected(itemIndex);
    }
    else
    {
        // Clear selection when clicking empty space
        if (!(QApplication::keyboardModifiers() & (Qt::ControlModifier | Qt::ShiftModifier)))
        {
            selectedItems.clear();
            lastSelectedItem = -1;
            currentlyNavigatedSignal.clear();
            currentEventIndex = -1;
            update();
            emit itemSelected(-1);
        }
    }
}


void WaveformWidget::handleWaveformClick(const QPoint &pos)
{
    int waveformStartX = signalNamesWidth + valuesColumnWidth;

    // Check if click is in waveform area (not in names or values columns)
    if (pos.x() >= waveformStartX && pos.y() >= timeMarkersHeight)
    {
        // Calculate the maximum Y position where signals exist
        int maxSignalY = timeMarkersHeight;
        for (int i = 0; i < displayItems.size(); i++) {
            const auto &item = displayItems[i];
            int itemHeight = (item.type == DisplayItem::Signal) ? signalHeight : 30;
            maxSignalY += itemHeight;
        }
        
        // Add some padding
        maxSignalY += 10;
        
        // Only process clicks that are within the signal area (not empty space below)
        if (pos.y() <= maxSignalY) {
            // Store old cursor time to detect changes
            int oldCursorTime = cursorTime;
            
            // Also set cursor time
            int clickXInWaveform = pos.x() - waveformStartX;
            cursorTime = xToTime(clickXInWaveform);
            showCursor = true;

            // Try to select signal at this position
            selectSignalAtPosition(pos);

            // If cursor time changed and we have a selected signal, update navigation
            if (cursorTime != oldCursorTime && !currentlyNavigatedSignal.isEmpty()) {
                resetNavigationForCurrentSignal();
                
                // Emit cursor time change
                emit cursorTimeChanged(cursorTime);
            }

            update();
        }
    }
}
# File: CMakeLists.txt
cmake_minimum_required(VERSION 3.16)

project(OWV VERSION 0.1 LANGUAGES CXX)

set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Widgets Concurrent)
find_package(Qt${QT_VERSION_MAJOR} REQUIRED COMPONENTS Widgets Concurrent)

set(PROJECT_SOURCES
    main.cpp
    mainwindow.cpp
    mainwindow.h
    vcdparser.cpp
    vcdparser.h
    waveformwidget.cpp
    waveformwidget.h
    SignalSelectionDialog.cpp
    SignalSelectionDialog.h
)

if(${QT_VERSION_MAJOR} GREATER_EQUAL 6)
    qt_add_executable(OWV
        MANUAL_FINALIZATION
        ${PROJECT_SOURCES}
    )
    
    # For Qt6
    target_link_libraries(OWV PRIVATE 
        Qt${QT_VERSION_MAJOR}::Widgets 
        Qt${QT_VERSION_MAJOR}::Concurrent
    )
    
    # Qt for iOS sets MACOSX_BUNDLE_GUI_IDENTIFIER automatically since Qt 6.1.
    # If you are developing for iOS or macOS you should consider setting an
    # explicit, fixed bundle identifier manually though.
    if(${QT_VERSION} VERSION_LESS 6.1.0)
      set(BUNDLE_ID_OPTION MACOSX_BUNDLE_GUI_IDENTIFIER com.example.OWV)
    endif()
    set_target_properties(OWV PROPERTIES
        ${BUNDLE_ID_OPTION}
        MACOSX_BUNDLE_BUNDLE_VERSION ${PROJECT_VERSION}
        MACOSX_BUNDLE_SHORT_VERSION_STRING ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}
        MACOSX_BUNDLE TRUE
        WIN32_EXECUTABLE TRUE
    )
    
    if(QT_VERSION_MAJOR EQUAL 6)
        qt_finalize_executable(OWV)
    endif()
else()
    # For Qt5
    if(ANDROID)
        add_library(OWV SHARED
            ${PROJECT_SOURCES}
        )
        # Define properties for Android with Qt 5 after find_package() calls as:
        # set(ANDROID_PACKAGE_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/android")
    else()
        add_executable(OWV
            ${PROJECT_SOURCES}
        )
        
        set_target_properties(OWV PROPERTIES
            MACOSX_BUNDLE_BUNDLE_VERSION ${PROJECT_VERSION}
            MACOSX_BUNDLE_SHORT_VERSION_STRING ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}
            MACOSX_BUNDLE TRUE
            WIN32_EXECUTABLE TRUE
        )
    endif()
    
    target_link_libraries(OWV PRIVATE 
        Qt${QT_VERSION_MAJOR}::Widgets 
        Qt${QT_VERSION_MAJOR}::Concurrent
    )
endif()

include(GNUInstallDirs)
install(TARGETS OWV
    BUNDLE DESTINATION .
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)

configure_file(vcd_port_mapper.py ${CMAKE_CURRENT_BINARY_DIR}/vcd_port_mapper.py COPYONLY)
