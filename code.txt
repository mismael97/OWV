#ifndef SIGNALSELECTIONDIALOG_H
#define SIGNALSELECTIONDIALOG_H

#include <QDialog>
#include <QTreeWidget>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QDialogButtonBox>
#include <QLineEdit>
#include <QLabel>
#include "vcdparser.h"

class SignalSelectionDialog : public QDialog
{
    Q_OBJECT
public:
    explicit SignalSelectionDialog(QWidget *parent = nullptr);
    void setAvailableSignals(const QVector<VCDSignal> &allSignals, const QList<VCDSignal> &visibleSignals);
    QList<VCDSignal> getSelectedSignals() const;

private slots:
    void selectAll();
    void deselectAll();
    void onSearchTextChanged(const QString &text);

private:
    void filterTree(const QString &filter);
    void expandAllParents(QTreeWidgetItem *item);

    QTreeWidget *signalTree;
    QPushButton *selectAllButton;
    QPushButton *deselectAllButton;
    QDialogButtonBox *buttonBox;
    QLineEdit *searchEdit;
    QTreeWidgetItem *lastHighlightedItem;
};

#endif // SIGNALSELECTIONDIALOG_H
#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QTreeWidget>
#include <QSplitter>
#include <QToolBar>
#include <QStatusBar>
#include <QFileDialog>
#include <QMessageBox>
#include <QScrollBar>
#include <QLabel>
#include <QPushButton>
#include <QHBoxLayout>
#include <QWidget>
#include <QListWidget>
#include <QListWidgetItem>
#include <QDialog>
#include <QDialogButtonBox>
#include <QKeyEvent>
#include "vcdparser.h"
#include "waveformwidget.h"

class SignalSelectionDialog;

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

protected:
    void keyPressEvent(QKeyEvent *event) override;

private slots:
    void openFile();
    void zoomIn();
    void zoomOut();
    void zoomFit();
    void updateTimeDisplay(int time);
    void about();
    void showAddSignalsDialog();
    void removeSelectedSignals();
    void toggleBusDisplayFormat();
    void resetSignalColors();
    void toggleHighlightBusses();
    void setBusHexFormat();
    void setBusBinaryFormat();
    void setBusOctalFormat();
    void setBusDecimalFormat();
    void updateBusFormatActions();

private:
    // Wave menu actions
    QMenu *waveMenu;
    QAction *defaultColorsAction;
    QAction *highlightBussesAction;
    QMenu *busFormatMenu;
    QAction *busHexAction;
    QAction *busBinaryAction;
    QAction *busOctalAction;
    QAction *busDecimalAction;
    QAction *resetColorsAction;
    void createActions();
    void createToolBar();
    void createStatusBar();
    void setupUI();
    void loadVcdFile(const QString &filename);
    void loadDefaultVcdFile();

    // UI Components
    WaveformWidget *waveformWidget;
    QScrollBar *timeScrollBar;

    // Toolbar Actions
    QAction *openAction;
    QAction *zoomInAction;
    QAction *zoomOutAction;
    QAction *zoomFitAction;
    QAction *aboutAction;

    // Bottom controls
    QPushButton *addSignalsButton;
    QPushButton *removeSignalsButton;

    // Status Bar
    QLabel *statusLabel;
    QLabel *timeLabel;

    // Data
    VCDParser *vcdParser;
};

#endif // MAINWINDOW_H
// file: vcdparser.h
#ifndef VCDPARSER_H
#define VCDPARSER_H

#include <QObject>
#include <QString>
#include <QVector>
#include <QMap>
#include <QFile>
#include <QTextStream>
#include <QSet>

struct VCDSignal {
    QString identifier;
    QString name;
    QString scope;
    int width;
    QString type;

    bool operator==(const VCDSignal& other) const {
        return identifier == other.identifier;
    }
};

Q_DECLARE_METATYPE(VCDSignal)

struct VCDValueChange {
    int timestamp;
    QString value;
};

class VCDParser : public QObject
{
    Q_OBJECT

public:
    explicit VCDParser(QObject *parent = nullptr);
    ~VCDParser();

    bool parseFile(const QString &filename);
    QString getError() const { return errorString; }

    const QVector<VCDSignal>& getSignals() const { return vcdSignals; }
    const QMap<QString, QVector<VCDValueChange>>& getValueChanges() const { return valueChanges; }
    int getEndTime() const { return endTime; }
    const QMap<QString, VCDSignal>& getIdentifierMap() const { return identifierMap; }

private:
    bool parseHeader(QTextStream &stream);
    bool parseValueChanges(QTextStream &stream);
    void parseScopeLine(const QString &line);
    void parseVarLine(const QString &line);
    void parseTimescale(const QString &line);

    QString errorString;
    QVector<VCDSignal> vcdSignals;
    QMap<QString, VCDSignal> identifierMap;
    QMap<QString, QVector<VCDValueChange>> valueChanges;
    QString currentScope;
    int endTime;
    QString timescale;
};

#endif // VCDPARSER_H
#ifndef WAVEFORMWIDGET_H
#define WAVEFORMWIDGET_H

#include <QWidget>
#include <QPainter>
#include <QScrollBar>
#include <QWheelEvent>
#include <QMouseEvent>
#include <QVector>
#include <QList>
#include <QLabel>
#include <QMenu>
#include <QContextMenuEvent>
#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QSet>
#include <QInputDialog>
#include <QColorDialog>

#include "vcdparser.h"

// Simple signal display structure
struct DisplaySignal {
    VCDSignal signal;
};

// Space structure
struct DisplaySpace {
    QString name;
};

// Unified display item
struct DisplayItem {
    enum Type { Signal, Space };
    Type type;
    
    // Only one of these is valid based on type
    DisplaySignal signal;
    DisplaySpace space;
    
    // Constructor for signal
    static DisplayItem createSignal(const VCDSignal& sig) {
        DisplayItem item;
        item.type = Signal;
        item.signal = {sig};
        return item;
    }
    
    // Constructor for space
    static DisplayItem createSpace(const QString& name = "") {
        DisplayItem item;
        item.type = Space;
        item.space = {name};
        return item;
    }
    
    QString getName() const {
        switch(type) {
            case Signal: {
                QString name = signal.signal.scope.isEmpty() ? signal.signal.name : signal.signal.scope + "." + signal.signal.name;
                // Remove any width information like "[3:0]" from the name
                int bracketPos = name.indexOf('[');
                if (bracketPos != -1) {
                    name = name.left(bracketPos).trimmed();
                }
                return name;
            }
            case Space: 
                return space.name.isEmpty() ? "⏐" : "⏐ " + space.name;
        }
        return "";
    }
    
    // Helper function to get full scope path for searching
    QString getFullPath() const {
        if (type == Signal) {
            QString fullPath = signal.signal.scope.isEmpty() ? signal.signal.name : signal.signal.scope + "." + signal.signal.name;
            // Remove any width information for consistency
            int bracketPos = fullPath.indexOf('[');
            if (bracketPos != -1) {
                fullPath = fullPath.left(bracketPos).trimmed();
            }
            return fullPath;
        }
        return getName();
    }
    
    int getHeight() const {
        return 30; // Fixed height for all items
    }
    
    bool isSelectable() const { return true; }
    bool isMovable() const { return true; }
};

class WaveformWidget : public QWidget
{
    Q_OBJECT

public:
    enum BusFormat { Hex, Binary, Octal, Decimal };
    
    explicit WaveformWidget(QWidget *parent = nullptr);
    void setVcdData(VCDParser *parser);
    void setVisibleSignals(const QList<VCDSignal> &visibleSignals);
    void zoomIn();
    void zoomOut();
    void zoomFit();
    void removeSelectedSignals();
    void selectAllSignals();
    void resetSignalColors();
    void setHighlightBusses(bool highlight);
    void setBusDisplayFormat(BusFormat format);
    BusFormat getBusDisplayFormat() const { return busDisplayFormat; }
    int getSelectedSignal() const { return selectedItems.isEmpty() ? -1 : *selectedItems.begin(); }
    QList<int> getSelectedItemIndices() const { return selectedItems.values(); }
    
    // Item management
    int getItemCount() const { return displayItems.size(); }
    const DisplayItem* getItem(int index) const;

signals:
    void timeChanged(int time);
    void itemSelected(int itemIndex);
    void contextMenuRequested(const QPoint &pos, int itemIndex);

protected:
    void paintEvent(QPaintEvent *event) override;
    void wheelEvent(QWheelEvent *event) override;
    void mousePressEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;
    void mouseReleaseEvent(QMouseEvent *event) override;
    void resizeEvent(QResizeEvent *event) override;
    void contextMenuEvent(QContextMenuEvent *event) override;
    void keyPressEvent(QKeyEvent *event) override;
    void mouseDoubleClickEvent(QMouseEvent *event) override;

private:
    void updateCursorTime(const QPoint &pos);
    void drawSignalNamesColumn(QPainter &painter);
    void drawSignalValuesColumn(QPainter &painter);
    void drawWaveformArea(QPainter &painter);
    void drawTimeCursor(QPainter &painter);
    void drawGrid(QPainter &painter);
    void drawSignals(QPainter &painter);
    void drawSignalWaveform(QPainter &painter, const VCDSignal &signal, int yPos);
    void drawBusWaveform(QPainter &painter, const VCDSignal &signal, int yPos);
    void updateScrollBar();
    int timeToX(int time) const;
    int xToTime(int x) const;
    QString getSignalValueAtTime(const QString &identifier, int time) const;
    QString getBusValueAtTime(const QString &identifier, int time) const;
    int calculateTimeStep(int startTime, int endTime) const;
    int getItemAtPosition(const QPoint &pos) const;
    int getItemYPosition(int index) const;
    void showContextMenu(const QPoint &pos, int itemIndex);
    void addSpaceAbove(int index);
    void addSpaceBelow(int index);
    void renameItem(int itemIndex);
    QString promptForName(const QString &title, const QString &defaultName = "");
    
    // Color management
    void changeSignalColor(int itemIndex);
    QColor getSignalColor(const QString& identifier) const;
    
    // Splitter handling
    bool isOverNamesSplitter(const QPoint &pos) const;
    bool isOverValuesSplitter(const QPoint &pos) const;
    void updateSplitterPositions();
    
    // Search functionality
    QString searchText;
    bool isSearchActive = false;
    QSet<int> searchResults;
    void drawSearchBar(QPainter &painter);
    void handleSearchInput(const QString &text);
    void updateSearchResults();
    void applySearchFilter();
    
    // Drag and movement
    void startDrag(int itemIndex);
    void performDrag(int mouseY);
    void moveItem(int itemIndex, int newIndex);
    
    // Selection
    void handleMultiSelection(int itemIndex, QMouseEvent *event);
    
    // Helper methods
    bool isSignalItem(int index) const { 
        return index >= 0 && index < displayItems.size() && displayItems[index].type == DisplayItem::Signal; 
    }
    bool isSpaceItem(int index) const { 
        return index >= 0 && index < displayItems.size() && displayItems[index].type == DisplayItem::Space; 
    }
    VCDSignal getSignalFromItem(int index) const {
        return isSignalItem(index) ? displayItems[index].signal.signal : VCDSignal();
    }

    // Bus display helpers
    QString formatBusValue(const QString& binaryValue) const;
    bool isValidBinary(const QString& value) const;
    QString binaryToHex(const QString& binaryValue) const;
    QString binaryToOctal(const QString& binaryValue) const;
    QString binaryToDecimal(const QString& binaryValue) const;

    VCDParser *vcdParser;

    // Layout parameters
    int signalNamesWidth = 250;
    int valuesColumnWidth = 120;
    double timeScale;
    int timeOffset;
    int timeMarkersHeight;
    int topMargin;

    // Display items
    QList<DisplayItem> displayItems;

    // Signal colors
    QMap<QString, QColor> signalColors;
    bool highlightBusses = false;
    BusFormat busDisplayFormat = Hex;

    // Splitter state
    bool draggingNamesSplitter = false;
    bool draggingValuesSplitter = false;

    // Drag state
    bool isDragging;
    bool isDraggingItem;
    int dragStartX;
    int dragStartOffset;
    int dragItemIndex;
    int dragStartY;
    QPoint dragStartPos;

    // Selection state
    QSet<int> selectedItems;
    int lastSelectedItem;

    // Time cursor and values display
    int cursorTime = 0;
    bool showCursor = true;

    QScrollBar *horizontalScrollBar;
};

#endif // WAVEFORMWIDGET_H#include "SignalSelectionDialog.h"
#include <QHeaderView>
#include <QDebug>

SignalSelectionDialog::SignalSelectionDialog(QWidget *parent)
    : QDialog(parent), lastHighlightedItem(nullptr)
{
    setWindowTitle("Add Signals to Waveform");
    setMinimumSize(600, 500);

    QVBoxLayout *mainLayout = new QVBoxLayout(this);

    // Search bar
    QHBoxLayout *searchLayout = new QHBoxLayout();
    QLabel *searchLabel = new QLabel("Search:");
    searchEdit = new QLineEdit();
    searchEdit->setPlaceholderText("Type to search signals...");
    searchEdit->setClearButtonEnabled(true);
    
    connect(searchEdit, &QLineEdit::textChanged, this, &SignalSelectionDialog::onSearchTextChanged);
    
    searchLayout->addWidget(searchLabel);
    searchLayout->addWidget(searchEdit);
    
    // Signal tree
    signalTree = new QTreeWidget();
    signalTree->setHeaderLabels({"Signal", "Width", "Type", "Identifier"});
    signalTree->setAlternatingRowColors(true);
    signalTree->header()->setStretchLastSection(false);
    signalTree->header()->setSectionResizeMode(0, QHeaderView::Stretch);
    signalTree->header()->setSectionResizeMode(1, QHeaderView::ResizeToContents);
    signalTree->header()->setSectionResizeMode(2, QHeaderView::ResizeToContents);
    signalTree->header()->setSectionResizeMode(3, QHeaderView::ResizeToContents);

    // Controls
    QHBoxLayout *controlsLayout = new QHBoxLayout();
    selectAllButton = new QPushButton("Select All");
    deselectAllButton = new QPushButton("Deselect All");

    connect(selectAllButton, &QPushButton::clicked, this, &SignalSelectionDialog::selectAll);
    connect(deselectAllButton, &QPushButton::clicked, this, &SignalSelectionDialog::deselectAll);

    controlsLayout->addWidget(selectAllButton);
    controlsLayout->addWidget(deselectAllButton);
    controlsLayout->addStretch();

    // Buttons
    buttonBox = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
    connect(buttonBox, &QDialogButtonBox::accepted, this, &QDialog::accept);
    connect(buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);

    mainLayout->addLayout(searchLayout);
    mainLayout->addWidget(signalTree);
    mainLayout->addLayout(controlsLayout);
    mainLayout->addWidget(buttonBox);
}


void SignalSelectionDialog::setAvailableSignals(const QVector<VCDSignal> &allSignals, const QList<VCDSignal> &visibleSignals)
{
    signalTree->clear();
    lastHighlightedItem = nullptr;

    // Create a set of visible signal identifiers for quick lookup
    QSet<QString> visibleSignalIdentifiers;
    for (const auto& signal : visibleSignals) {
        visibleSignalIdentifiers.insert(signal.identifier);
    }

    QMap<QString, QTreeWidgetItem*> scopeItems;

    for (const auto& signal : allSignals) {
        // Skip signals that are already visible in the waveform
        if (visibleSignalIdentifiers.contains(signal.identifier)) {
            continue;
        }

        QString scopePath = signal.scope;
        if (!scopeItems.contains(scopePath)) {
            QStringList scopeParts = scopePath.split('.');
            QTreeWidgetItem *parent = nullptr;
            QString currentPath;

            for (const QString& part : scopeParts) {
                if (!currentPath.isEmpty()) currentPath += ".";
                currentPath += part;

                if (!scopeItems.contains(currentPath)) {
                    QTreeWidgetItem *item = new QTreeWidgetItem();
                    item->setText(0, part);
                    item->setData(0, Qt::UserRole, currentPath);

                    if (parent) {
                        parent->addChild(item);
                    } else {
                        signalTree->addTopLevelItem(item);
                    }

                    scopeItems[currentPath] = item;
                    parent = item;
                } else {
                    parent = scopeItems[currentPath];
                }
            }
        }

        QTreeWidgetItem *signalItem = new QTreeWidgetItem();
        signalItem->setText(0, signal.name);
        signalItem->setText(1, QString::number(signal.width));
        signalItem->setText(2, signal.type);
        signalItem->setText(3, signal.identifier);
        signalItem->setData(0, Qt::UserRole, QVariant::fromValue(signal));
        signalItem->setFlags(signalItem->flags() | Qt::ItemIsUserCheckable);
        signalItem->setCheckState(0, Qt::Unchecked);

        scopeItems[scopePath]->addChild(signalItem);
    }

    // Apply current search filter if any
    if (!searchEdit->text().isEmpty()) {
        filterTree(searchEdit->text());
    } else {
        signalTree->expandAll();
    }
}


QList<VCDSignal> SignalSelectionDialog::getSelectedSignals() const
{
    QList<VCDSignal> selectedSignals;

    QTreeWidgetItemIterator it(signalTree);
    while (*it) {
        if ((*it)->checkState(0) == Qt::Checked) {
            QVariant data = (*it)->data(0, Qt::UserRole);
            if (data.canConvert<VCDSignal>()) {
                VCDSignal signal = data.value<VCDSignal>();
                selectedSignals.append(signal);
                qDebug() << "Selected signal:" << signal.name << "ID:" << signal.identifier;
            }
        }
        ++it;
    }

    return selectedSignals;
}

void SignalSelectionDialog::selectAll()
{
    QTreeWidgetItemIterator it(signalTree);
    while (*it) {
        QVariant data = (*it)->data(0, Qt::UserRole);
        if (data.canConvert<VCDSignal>()) {
            (*it)->setCheckState(0, Qt::Checked);
        }
        ++it;
    }
}

void SignalSelectionDialog::deselectAll()
{
    QTreeWidgetItemIterator it(signalTree);
    while (*it) {
        QVariant data = (*it)->data(0, Qt::UserRole);
        if (data.canConvert<VCDSignal>()) {
            (*it)->setCheckState(0, Qt::Unchecked);
        }
        ++it;
    }
}

void SignalSelectionDialog::onSearchTextChanged(const QString &text)
{
    filterTree(text);
}

void SignalSelectionDialog::filterTree(const QString &filter)
{
    if (filter.isEmpty()) {
        // Show all items and expand all
        QTreeWidgetItemIterator it(signalTree);
        while (*it) {
            (*it)->setHidden(false);
            ++it;
        }
        signalTree->expandAll();
        lastHighlightedItem = nullptr;
        return;
    }

    QString filterLower = filter.toLower();
    QTreeWidgetItemIterator it(signalTree);
    
    // First, hide all items
    while (*it) {
        (*it)->setHidden(true);
        (*it)->setBackground(0, QBrush()); // Clear any previous highlighting
        ++it;
    }

    // Show and highlight matching items and their parents
    it = QTreeWidgetItemIterator(signalTree);
    while (*it) {
        QTreeWidgetItem *item = *it;
        QVariant data = item->data(0, Qt::UserRole);
        
        if (data.canConvert<VCDSignal>()) {
            // This is a signal item
            VCDSignal signal = data.value<VCDSignal>();
            QString signalPath = (signal.scope.isEmpty() ? signal.name : signal.scope + "." + signal.name).toLower();
            
            if (signalPath.contains(filterLower)) {
                // Show this signal and all its parents
                item->setHidden(false);
                item->setBackground(0, QColor(255, 255, 200)); // Highlight matching signals
                
                // Expand and show all parent items
                expandAllParents(item);
                
                lastHighlightedItem = item;
            }
        } else {
            // This is a scope item - check if it has any visible children
            bool hasVisibleChildren = false;
            for (int i = 0; i < item->childCount(); ++i) {
                if (!item->child(i)->isHidden()) {
                    hasVisibleChildren = true;
                    break;
                }
            }
            
            if (hasVisibleChildren) {
                item->setHidden(false);
                item->setExpanded(true);
            }
        }
        ++it;
    }
}

void SignalSelectionDialog::expandAllParents(QTreeWidgetItem *item)
{
    QTreeWidgetItem *parent = item->parent();
    while (parent) {
        parent->setHidden(false);
        parent->setExpanded(true);
        parent = parent->parent();
    }
}// file: main.cpp
#include "mainwindow.h"
#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication app(argc, argv);

    // Set application properties
    app.setApplicationName("VCD Wave Viewer");
    app.setApplicationVersion("1.0");
    app.setOrganizationName("VCDViewer");

    MainWindow window;
    window.show();

    return app.exec();
}
#include "mainwindow.h"
#include "SignalSelectionDialog.h"
#include <QTreeWidgetItemIterator>
#include <QFileInfo>
#include <QMessageBox>
#include <QSplitter>
#include <QToolBar>
#include <QStatusBar>
#include <QFileDialog>
#include <QLabel>
#include <QApplication>
#include <QPushButton>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QWidget>
#include <QDir>
#include <QToolButton>
#include <QKeyEvent>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), vcdParser(new VCDParser(this))
{
    qRegisterMetaType<VCDSignal>("VCDSignal");
    setWindowTitle("VCD Wave Viewer");
    setMinimumSize(1200, 800);

    createActions();
    setupUI();
    createToolBar();
    createStatusBar();

    loadDefaultVcdFile();
}

MainWindow::~MainWindow()
{
}

void MainWindow::keyPressEvent(QKeyEvent *event)
{
    if (event->key() == Qt::Key_Delete) {
        // Let the waveform widget handle deletion if it has focus
        if (waveformWidget->hasFocus() && !waveformWidget->getSelectedItemIndices().isEmpty()) {
            waveformWidget->removeSelectedSignals();
            event->accept();
        } else {
            // Fall back to the main window's delete handling
            removeSelectedSignals();
            event->accept();
        }
    } else if (event->key() == Qt::Key_A && event->modifiers() & Qt::ControlModifier) {
        waveformWidget->selectAllSignals();
        removeSignalsButton->setEnabled(true);
        event->accept();
    } else {
        QMainWindow::keyPressEvent(event);
    }
}

void MainWindow::createActions()
{
    openAction = new QAction("Open", this);
    openAction->setShortcut(QKeySequence::Open);
    connect(openAction, &QAction::triggered, this, &MainWindow::openFile);

    zoomInAction = new QAction("Zoom In", this);
    zoomInAction->setShortcut(QKeySequence::ZoomIn);
    connect(zoomInAction, &QAction::triggered, this, &MainWindow::zoomIn);

    resetColorsAction = new QAction("Reset Colors", this);
    connect(resetColorsAction, &QAction::triggered, this, &MainWindow::resetSignalColors);

    zoomOutAction = new QAction("Zoom Out", this);
    zoomOutAction->setShortcut(QKeySequence::ZoomOut);
    connect(zoomOutAction, &QAction::triggered, this, &MainWindow::zoomOut);

    zoomFitAction = new QAction("Zoom Fit", this);
    connect(zoomFitAction, &QAction::triggered, this, &MainWindow::zoomFit);

    aboutAction = new QAction("About", this);
    connect(aboutAction, &QAction::triggered, this, &MainWindow::about);

    // Wave menu actions
    defaultColorsAction = new QAction("Default Colors", this);
    connect(defaultColorsAction, &QAction::triggered, this, &MainWindow::resetSignalColors);

    highlightBussesAction = new QAction("Highlight Busses", this);
    highlightBussesAction->setCheckable(true);
    connect(highlightBussesAction, &QAction::triggered, this, &MainWindow::toggleHighlightBusses);


// Bus format actions
    busHexAction = new QAction("Hexadecimal", this);
    busHexAction->setCheckable(true);
    busHexAction->setChecked(true);
    connect(busHexAction, &QAction::triggered, this, &MainWindow::setBusHexFormat);


     busBinaryAction = new QAction("Binary", this);
    busBinaryAction->setCheckable(true);
    connect(busBinaryAction, &QAction::triggered, this, &MainWindow::setBusBinaryFormat);

    busOctalAction = new QAction("Octal", this);
    busOctalAction->setCheckable(true);
    connect(busOctalAction, &QAction::triggered, this, &MainWindow::setBusOctalFormat);

    busDecimalAction = new QAction("Decimal", this);
    busDecimalAction->setCheckable(true);
    connect(busDecimalAction, &QAction::triggered, this, &MainWindow::setBusDecimalFormat);
}

void MainWindow::resetSignalColors()
{
    waveformWidget->resetSignalColors();
}

void MainWindow::createToolBar()
{
    QToolBar *toolBar = addToolBar("Main Toolbar");
    toolBar->addAction(openAction);
    toolBar->addSeparator();
    
    // Wave menu
    waveMenu = new QMenu("Wave");
    
    // Signal colors submenu
    QMenu *signalColorsMenu = new QMenu("Signal Colors");
    signalColorsMenu->addAction(defaultColorsAction);
    signalColorsMenu->addAction(highlightBussesAction);
    
    // Bus format submenu
    busFormatMenu = new QMenu("Bus Format");
    busFormatMenu->addAction(busHexAction);
    busFormatMenu->addAction(busBinaryAction);
    busFormatMenu->addAction(busOctalAction);
    busFormatMenu->addAction(busDecimalAction);
    
    waveMenu->addMenu(signalColorsMenu);
    waveMenu->addMenu(busFormatMenu);
    
    QToolButton *waveButton = new QToolButton();
    waveButton->setMenu(waveMenu);
    waveButton->setPopupMode(QToolButton::InstantPopup);
    waveButton->setText("Wave");
    toolBar->addWidget(waveButton);
    
    toolBar->addSeparator();
    toolBar->addAction(zoomInAction);
    toolBar->addAction(zoomOutAction);
    toolBar->addAction(zoomFitAction);
    toolBar->addSeparator();
    toolBar->addAction(aboutAction);
}

void MainWindow::createStatusBar()
{
    statusLabel = new QLabel("Ready");
    statusBar()->addWidget(statusLabel);

    timeLabel = new QLabel("Time: 0");
    statusBar()->addPermanentWidget(timeLabel);
}

void MainWindow::setupUI()
{
    // Create central widget with waveform
    QWidget *centralWidget = new QWidget();
    QVBoxLayout *centralLayout = new QVBoxLayout(centralWidget);
    centralLayout->setContentsMargins(0, 0, 0, 0);
    centralLayout->setSpacing(0);

    // Create waveform widget (now includes signal names column)
    waveformWidget = new WaveformWidget();
    connect(waveformWidget, &WaveformWidget::timeChanged,
            this, &MainWindow::updateTimeDisplay);
    connect(waveformWidget, &WaveformWidget::itemSelected, this, [this](int index) {
    // Enable/disable remove button based on selection
    removeSignalsButton->setEnabled(index >= 0);
});

    // === BOTTOM CONTROLS ===
    QWidget *bottomControls = new QWidget();
    QHBoxLayout *bottomLayout = new QHBoxLayout(bottomControls);
    bottomLayout->setContentsMargins(10, 5, 10, 5);

    addSignalsButton = new QPushButton("+ Add Signals");
    removeSignalsButton = new QPushButton("🗑️");

    addSignalsButton->setStyleSheet("QPushButton { padding: 8px; font-weight: bold; background-color: #4CAF50; color: white; }");
    removeSignalsButton->setStyleSheet("QPushButton { padding: 8px; font-weight: bold; background-color: #f44336; color: white; }");
    removeSignalsButton->setEnabled(false);
    removeSignalsButton->setToolTip("Remove selected signal (Delete)");

    connect(addSignalsButton, &QPushButton::clicked, this, &MainWindow::showAddSignalsDialog);
    connect(removeSignalsButton, &QPushButton::clicked, this, &MainWindow::removeSelectedSignals);

    bottomLayout->addWidget(addSignalsButton);
    bottomLayout->addWidget(removeSignalsButton);
    bottomLayout->addStretch();

    centralLayout->addWidget(waveformWidget, 1);
    centralLayout->addWidget(bottomControls);

    setCentralWidget(centralWidget);
}

void MainWindow::showAddSignalsDialog()
{
    if (!vcdParser) return;

    SignalSelectionDialog dialog(this);
    
    // Get current signals using public method
    QList<VCDSignal> currentSignals;
    for (int i = 0; i < waveformWidget->getItemCount(); i++) {
        const DisplayItem* item = waveformWidget->getItem(i);
        if (item && item->type == DisplayItem::Signal) {
            currentSignals.append(item->signal.signal);
        }
    }
    
    dialog.setAvailableSignals(vcdParser->getSignals(), currentSignals);

    if (dialog.exec() == QDialog::Accepted) {
        QList<VCDSignal> newSignalsToAdd = dialog.getSelectedSignals();
        if (!newSignalsToAdd.isEmpty()) {
            // Add new signals to display using public method
            for (const auto& signal : newSignalsToAdd) {
                // We need to add this through a public method in WaveformWidget
                // For now, we'll use setVisibleSignals which replaces all signals
                // In the future, we should add an addSignals method to WaveformWidget
                currentSignals.append(signal);
            }
            
            waveformWidget->setVisibleSignals(currentSignals);
            
            int signalCount = 0;
            for (int i = 0; i < waveformWidget->getItemCount(); i++) {
                const DisplayItem* item = waveformWidget->getItem(i);
                if (item && item->type == DisplayItem::Signal) {
                    signalCount++;
                }
            }
            
            statusLabel->setText(QString("%1 signal(s) displayed").arg(signalCount));
            removeSignalsButton->setEnabled(false); // Clear selection
        }
    }
}
// In mainwindow.cpp, update the removeSelectedSignals method:
void MainWindow::removeSelectedSignals()
{
    // Check if there are any selected items in the waveform widget
    if (!waveformWidget->getSelectedItemIndices().isEmpty()) {
        waveformWidget->removeSelectedSignals();
        removeSignalsButton->setEnabled(false);

        // Count only signals for display (not spaces)
        int signalCount = 0;
        for (int i = 0; i < waveformWidget->getItemCount(); i++) {
            const DisplayItem* item = waveformWidget->getItem(i);
            if (item && item->type == DisplayItem::Signal) {
                signalCount++;
            }
        }

        statusLabel->setText(QString("%1 signal(s) displayed").arg(signalCount));
    }
}

void MainWindow::loadDefaultVcdFile()
{
    QString defaultPath = "F:/OWV/test.vcd";

    if (QFile::exists(defaultPath)) {
        loadVcdFile(defaultPath);
    } else {
        statusLabel->setText("Default VCD file not found. Use File → Open to load a VCD file.");
        qDebug() << "Default VCD file not found:" << defaultPath;
    }
}

void MainWindow::openFile()
{
    QString filename = QFileDialog::getOpenFileName(
        this, "Open VCD File", "C:/Users/mismael/Desktop/OWV", "VCD Files (*.vcd)");

    if (!filename.isEmpty()) {
        loadVcdFile(filename);
    }
}

void MainWindow::loadVcdFile(const QString &filename)
{
    statusLabel->setText("Loading VCD file...");
    QApplication::processEvents();

    if (vcdParser->parseFile(filename)) {
        statusLabel->setText(QString("Loaded: %1 (%2 signals)").arg(QFileInfo(filename).fileName()).arg(vcdParser->getSignals().size()));
        waveformWidget->setVcdData(vcdParser);
    } else {
        QMessageBox::critical(this, "Error",
                              "Failed to parse VCD file: " + vcdParser->getError());
        statusLabel->setText("Ready");
    }
}

void MainWindow::zoomIn()
{
    waveformWidget->zoomIn();
}

void MainWindow::zoomOut()
{
    waveformWidget->zoomOut();
}

void MainWindow::zoomFit()
{
    waveformWidget->zoomFit();
}

void MainWindow::updateTimeDisplay(int time)
{
    timeLabel->setText(QString("Time: %1").arg(time));
}

void MainWindow::about()
{
    QMessageBox::about(this, "About VCD Wave Viewer",
                       "VCD Wave Viewer\n\n"
                       "A professional waveform viewer for Value Change Dump (VCD) files.\n"
                       "Built with Qt C++\n\n"
                       "Features:\n"
                       "- Unified signal names and waveform display\n"
                       "- Dark theme\n"
                       "- Drag to reorder signals\n"
                       "- Professional signal selection dialog\n"
                       "- Mouse wheel navigation");
}

// Add the toggle method:
void MainWindow::toggleBusDisplayFormat()
{
    if (sender() == busHexAction) {
        waveformWidget->setBusDisplayFormat(WaveformWidget::Hex);
        busHexAction->setChecked(true);
        busBinaryAction->setChecked(false);
    } else if (sender() == busBinaryAction) {
        waveformWidget->setBusDisplayFormat(WaveformWidget::Binary);
        busHexAction->setChecked(false);
        busBinaryAction->setChecked(true);
    }
}

void MainWindow::toggleHighlightBusses()
{
    waveformWidget->setHighlightBusses(highlightBussesAction->isChecked());
}

void MainWindow::setBusHexFormat()
{
    waveformWidget->setBusDisplayFormat(WaveformWidget::Hex);
    updateBusFormatActions();
}

void MainWindow::setBusBinaryFormat()
{
    waveformWidget->setBusDisplayFormat(WaveformWidget::Binary);
    updateBusFormatActions();
}

void MainWindow::setBusOctalFormat()
{
    waveformWidget->setBusDisplayFormat(WaveformWidget::Octal);
    updateBusFormatActions();
}

void MainWindow::setBusDecimalFormat()
{
    waveformWidget->setBusDisplayFormat(WaveformWidget::Decimal);
    updateBusFormatActions();
}

void MainWindow::updateBusFormatActions()
{
    busHexAction->setChecked(false);
    busBinaryAction->setChecked(false);
    busOctalAction->setChecked(false);
    busDecimalAction->setChecked(false);
    
    switch(waveformWidget->getBusDisplayFormat()) {
        case WaveformWidget::Hex: busHexAction->setChecked(true); break;
        case WaveformWidget::Binary: busBinaryAction->setChecked(true); break;
        case WaveformWidget::Octal: busOctalAction->setChecked(true); break;
        case WaveformWidget::Decimal: busDecimalAction->setChecked(true); break;
    }
}#include "vcdparser.h"
#include <QRegularExpression>
#include <QDebug>

VCDParser::VCDParser(QObject *parent)
    : QObject(parent), endTime(0)
{
}

VCDParser::~VCDParser()
{
}

bool VCDParser::parseFile(const QString &filename)
{
    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        errorString = "Cannot open file: " + filename;
        return false;
    }

    QTextStream stream(&file);
    vcdSignals.clear();
    valueChanges.clear();
    identifierMap.clear();
    currentScope.clear();
    endTime = 0;

    if (!parseHeader(stream)) {
        return false;
    }

    if (!parseValueChanges(stream)) {
        return false;
    }

    file.close();

    qDebug() << "VCD parsing completed";
    qDebug() << "Signals found:" << vcdSignals.size();
    for (const auto& signal : vcdSignals) {
        qDebug() << "Signal:" << signal.name << "Identifier:" << signal.identifier << "Scope:" << signal.scope;
    }
    qDebug() << "End time:" << endTime;

    return true;
}

bool VCDParser::parseHeader(QTextStream &stream)
{
    QRegularExpression scopeRegex("^\\$scope\\s+(\\w+)\\s+(\\S+)\\s*\\$end$");
    QRegularExpression varRegex("^\\$var\\s+(\\w+)\\s+(\\d+)\\s+(\\S+)\\s+(\\S+.*\\S+)\\s*\\$end$");
    QRegularExpression timescaleRegex("^\\$timescale\\s+(\\S+)\\s*\\$end$");

    while (!stream.atEnd()) {
        QString line = stream.readLine().trimmed();

        if (line.startsWith("$date")) {
            // Skip date section
            while (!stream.atEnd() && !line.contains("$end")) {
                line = stream.readLine().trimmed();
            }
        }
        else if (line.startsWith("$version")) {
            // Skip version section
            while (!stream.atEnd() && !line.contains("$end")) {
                line = stream.readLine().trimmed();
            }
        }
        else if (line.startsWith("$comment")) {
            // Skip comment section
            while (!stream.atEnd() && !line.contains("$end")) {
                line = stream.readLine().trimmed();
            }
        }
        else if (line.startsWith("$timescale")) {
            parseTimescale(line);
        }
        else if (line.startsWith("$scope")) {
            parseScopeLine(line);
        }
        else if (line.startsWith("$var")) {
            parseVarLine(line);
        }
        else if (line.startsWith("$upscope")) {
            // Move up one scope level
            int lastDot = currentScope.lastIndexOf('.');
            if (lastDot != -1) {
                currentScope = currentScope.left(lastDot);
            } else {
                currentScope.clear();
            }
        }
        else if (line.startsWith("$enddefinitions")) {
            // End of header
            break;
        }
    }

    return true;
}

void VCDParser::parseTimescale(const QString &line)
{
    QRegularExpression regex("^\\$timescale\\s+(\\S+)\\s*\\$end$");
    QRegularExpressionMatch match = regex.match(line);
    if (match.hasMatch()) {
        timescale = match.captured(1);
        qDebug() << "Timescale:" << timescale;
    }
}

void VCDParser::parseScopeLine(const QString &line)
{
    QRegularExpression regex("^\\$scope\\s+(\\w+)\\s+(\\S+)\\s*\\$end$");
    QRegularExpressionMatch match = regex.match(line);
    if (match.hasMatch()) {
        QString scopeType = match.captured(1);
        QString scopeName = match.captured(2);
        
        if (!currentScope.isEmpty()) {
            currentScope += "." + scopeName;
        } else {
            currentScope = scopeName;
        }
        qDebug() << "Entering scope:" << currentScope;
    }
}

void VCDParser::parseVarLine(const QString &line)
{
    // Improved regex to handle signal names with spaces and special characters
    QRegularExpression regex("^\\$var\\s+(\\w+)\\s+(\\d+)\\s+(\\S+)\\s+(.+)\\s*\\$end$");
    QRegularExpressionMatch match = regex.match(line);
    
    if (match.hasMatch()) {
        VCDSignal signal;
        signal.type = match.captured(1);
        signal.width = match.captured(2).toInt();
        signal.identifier = match.captured(3);
        
        // The signal name might have trailing spaces before $end, so trim it
        QString signalName = match.captured(4).trimmed();
        signal.name = signalName;
        signal.scope = currentScope;

        vcdSignals.append(signal);
        identifierMap[signal.identifier] = signal;
        
        // qDebug() << "Found signal:" << signal.name << "Identifier:" << signal.identifier 
        //          << "Type:" << signal.type << "Width:" << signal.width << "Scope:" << signal.scope;
    } else {
        qDebug() << "Failed to parse var line:" << line;
    }
}

bool VCDParser::parseValueChanges(QTextStream &stream)
{
    QRegularExpression timestampRegex("^#(\\d+)$");
    // Improved regex to handle all value change formats
    QRegularExpression valueChangeRegex("^([01xXzZrb])(\\S+)$");
    QRegularExpression vectorValueRegex("^[bB]([01xXzZ]+)\\s+(\\S+)$");

    int currentTime = 0;
    bool inDumpvars = false;

    while (!stream.atEnd()) {
        QString line = stream.readLine().trimmed();

        if (line.isEmpty()) continue;

        // Check for timestamp
        QRegularExpressionMatch timestampMatch = timestampRegex.match(line);
        if (timestampMatch.hasMatch()) {
            currentTime = timestampMatch.captured(1).toInt();
            endTime = qMax(endTime, currentTime);
            inDumpvars = false; // We're past the initial dumpvars section
            continue;
        }

        // Check for $dumpvars section
        if (line.startsWith("$dumpvars")) {
            inDumpvars = true;
            continue;
        }

        if (line.startsWith("$end") && inDumpvars) {
            inDumpvars = false;
            continue;
        }

        // Handle scalar value changes (0, 1, x, z)
        QRegularExpressionMatch valueMatch = valueChangeRegex.match(line);
        if (valueMatch.hasMatch()) {
            QString value = valueMatch.captured(1).toUpper();
            QString identifier = valueMatch.captured(2);

            // Handle special case where identifier might be just a single character
            if (identifier.length() == 1) {
                // This is a valid single-character identifier like #, %, etc.
                VCDValueChange change;
                change.timestamp = currentTime;
                change.value = value;
                valueChanges[identifier].append(change);
                qDebug() << "Scalar change at time" << currentTime << ":" << value << "->" << identifier;
            }
            continue;
        }

        // Handle vector value changes (binary)
        QRegularExpressionMatch vectorMatch = vectorValueRegex.match(line);
        if (vectorMatch.hasMatch()) {
            QString value = vectorMatch.captured(1);
            QString identifier = vectorMatch.captured(2);

            VCDValueChange change;
            change.timestamp = currentTime;
            change.value = value;
            valueChanges[identifier].append(change);
            // qDebug() << "Vector change at time" << currentTime << ":" << value << "->" << identifier;
            continue;
        }

        // Handle real value changes (if any)
        if (line.startsWith("r")) {
            // Real value change - format: r<value> <identifier>
            QStringList parts = line.split(" ", Qt::SkipEmptyParts);
            if (parts.size() >= 2) {
                QString value = parts[0].mid(1); // Remove 'r' prefix
                QString identifier = parts[1];
                
                VCDValueChange change;
                change.timestamp = currentTime;
                change.value = value;
                valueChanges[identifier].append(change);
                qDebug() << "Real change at time" << currentTime << ":" << value << "->" << identifier;
            }
        }
    }

    // Debug: print all signals found
    qDebug() << "=== All parsed signals ===";
    for (const auto& signal : vcdSignals) {
        // qDebug() << "Signal:" << signal.name << "ID:" << signal.identifier 
        //          << "Values:" << valueChanges[signal.identifier].size();
    }

    return true;
}#include "waveformwidget.h"
#include <QScrollBar>
#include <QWheelEvent>
#include <QMouseEvent>
#include <QResizeEvent>
#include <QPaintEvent>
#include <QContextMenuEvent>
#include <QKeyEvent>
#include <QInputDialog>
#include <QApplication>
#include <cmath>

WaveformWidget::WaveformWidget(QWidget *parent)
    : QWidget(parent), vcdParser(nullptr), timeScale(1.0), timeOffset(0),
      timeMarkersHeight(30), topMargin(10),
      isDragging(false), isDraggingItem(false), dragItemIndex(-1), lastSelectedItem(-1),
      busDisplayFormat(Hex), cursorTime(0), showCursor(true)
{
    setFocusPolicy(Qt::StrongFocus);
    setMouseTracking(true);

    horizontalScrollBar = new QScrollBar(Qt::Horizontal, this);
    connect(horizontalScrollBar, &QScrollBar::valueChanged, [this](int value) {
        timeOffset = value;
        update();
    });
}

void WaveformWidget::setVcdData(VCDParser *parser)
{
    vcdParser = parser;
    displayItems.clear();
    timeScale = 1.0;
    timeOffset = 0;
    selectedItems.clear();
    lastSelectedItem = -1;
    updateScrollBar();
    update();
}

void WaveformWidget::setVisibleSignals(const QList<VCDSignal> &visibleSignals)
{
    displayItems.clear();
    for (const auto &signal : visibleSignals) {
        displayItems.append(DisplayItem::createSignal(signal));
    }
    selectedItems.clear();
    lastSelectedItem = -1;
    update();
    emit itemSelected(-1);
}

const DisplayItem* WaveformWidget::getItem(int index) const
{
    if (index >= 0 && index < displayItems.size()) {
        return &displayItems[index];
    }
    return nullptr;
}

void WaveformWidget::removeSelectedSignals() {
    if (selectedItems.isEmpty()) return;

    // Remove items in reverse order
    QList<int> indices = selectedItems.values();
    std::sort(indices.begin(), indices.end(), std::greater<int>());
    
    for (int index : indices) {
        if (index >= 0 && index < displayItems.size()) {
            displayItems.removeAt(index);
        }
    }
    
    selectedItems.clear();
    lastSelectedItem = -1;
    update();
    emit itemSelected(-1);
}

void WaveformWidget::selectAllSignals()
{
    selectedItems.clear();
    for (int i = 0; i < displayItems.size(); i++)
    {
        selectedItems.insert(i);
    }
    lastSelectedItem = displayItems.size() - 1;
    update();
    emit itemSelected(selectedItems.isEmpty() ? -1 : *selectedItems.begin());
}

void WaveformWidget::zoomIn()
{
    timeScale *= 1.2;
    updateScrollBar();
    update();
}

void WaveformWidget::zoomOut()
{
    timeScale /= 1.2;
    if (timeScale < 0.1)
        timeScale = 0.1;
    updateScrollBar();
    update();
}

void WaveformWidget::zoomFit()
{
    if (!vcdParser || vcdParser->getEndTime() == 0)
        return;

    int availableWidth = width() - signalNamesWidth - valuesColumnWidth - 20;
    timeScale = static_cast<double>(availableWidth) / vcdParser->getEndTime();
    timeOffset = 0;
    updateScrollBar();
    update();
}

void WaveformWidget::resetSignalColors()
{
    signalColors.clear();
    update();
}

void WaveformWidget::setHighlightBusses(bool highlight)
{
    highlightBusses = highlight;
    update();
}

void WaveformWidget::setBusDisplayFormat(BusFormat format)
{
    busDisplayFormat = format;
    update();
}

void WaveformWidget::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event)

    QPainter painter(this);
    painter.setRenderHint(QPainter::Antialiasing);

    // Fill entire background with dark theme
    painter.fillRect(rect(), QColor(45, 45, 48));

    if (!vcdParser || displayItems.isEmpty()) {
        painter.setPen(QPen(Qt::white));
        painter.drawText(rect(), Qt::AlignCenter, "No signals selected");
        return;
    }

    drawSignalNamesColumn(painter);
    drawSignalValuesColumn(painter);
    drawWaveformArea(painter);
    drawTimeCursor(painter);
}


void WaveformWidget::drawSignalNamesColumn(QPainter &painter)
{
    // Draw signal names column background
    painter.fillRect(0, 0, signalNamesWidth, height(), QColor(37, 37, 38));

    // Draw names splitter
    painter.fillRect(signalNamesWidth - 1, 0, 2, height(), QColor(100, 100, 100));
    
    // Draw header
    painter.fillRect(0, 0, signalNamesWidth, timeMarkersHeight, QColor(60, 60, 60));
    painter.setPen(QPen(Qt::white));
    painter.drawText(5, timeMarkersHeight - 8, "Signal Name");

    // Draw search bar
    drawSearchBar(painter);
    
    int currentY = topMargin + timeMarkersHeight;
    
    for (int i = 0; i < displayItems.size(); i++) {
        const auto& item = displayItems[i];
        int itemHeight = item.getHeight();
        
        // Draw background based on selection and type
        bool isSelected = selectedItems.contains(i);
        bool isSearchMatch = searchResults.contains(i);
        
        if (isSelected) {
            painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(60, 60, 90));
        } else if (isSearchActive && isSearchMatch) {
            // Highlight search matches with a different color
            painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(80, 80, 120, 150));
        } else if (item.type == DisplayItem::Space) {
            painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(80, 160, 80, 120));
        } else if (i % 2 == 0) {
            painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(45, 45, 48));
        } else {
            painter.fillRect(0, currentY, signalNamesWidth, itemHeight, QColor(40, 40, 43));
        }

        // Draw item name with appropriate styling
        if (isSelected) {
            painter.setPen(QPen(Qt::white));
        } else if (isSearchActive && isSearchMatch) {
            painter.setPen(QPen(QColor(200, 200, 255))); // Light blue for search matches
        } else if (item.type == DisplayItem::Space) {
            painter.setPen(QPen(QColor(150, 255, 150)));
        } else {
            painter.setPen(QPen(Qt::white));
        }
        
        QString displayName = item.getName();
        int textIndent = 5;
        
        painter.drawText(textIndent, currentY + itemHeight / 2 + 4, displayName);

        // Draw horizontal separator
        painter.setPen(QPen(QColor(80, 80, 80)));
        painter.drawLine(0, currentY + itemHeight, signalNamesWidth, currentY + itemHeight);
        
        currentY += itemHeight;
    }
}



void WaveformWidget::drawSignalValuesColumn(QPainter &painter)
{
    if (!showCursor || cursorTime < 0 || !vcdParser) return;
    
    int valuesColumnStart = signalNamesWidth;
    
    // Draw values column background
    painter.fillRect(valuesColumnStart, 0, valuesColumnWidth, height(), QColor(50, 50, 60));
    
    // Draw values splitter
    painter.fillRect(valuesColumnStart + valuesColumnWidth - 1, 0, 2, height(), QColor(100, 100, 100));

    // Draw header
    painter.fillRect(valuesColumnStart, 0, valuesColumnWidth, timeMarkersHeight, QColor(70, 70, 80));
    painter.setPen(QPen(Qt::white));
    painter.drawText(valuesColumnStart + 5, timeMarkersHeight - 8, "Value @ Time");
    
    int currentY = topMargin + timeMarkersHeight;
    
    for (int i = 0; i < displayItems.size(); i++) {
        const auto& item = displayItems[i];
        int itemHeight = item.getHeight();
        
        // Draw background for this row
        bool isSelected = selectedItems.contains(i);
        bool isSearchMatch = searchResults.contains(i);
        
        if (isSelected) {
            painter.fillRect(valuesColumnStart, currentY, valuesColumnWidth, itemHeight, QColor(60, 60, 90));
        } else if (isSearchActive && isSearchMatch) {
            painter.fillRect(valuesColumnStart, currentY, valuesColumnWidth, itemHeight, QColor(80, 80, 120, 150));
        } else if (i % 2 == 0) {
            painter.fillRect(valuesColumnStart, currentY, valuesColumnWidth, itemHeight, QColor(50, 50, 60));
        } else {
            painter.fillRect(valuesColumnStart, currentY, valuesColumnWidth, itemHeight, QColor(45, 45, 55));
        }
        
        if (item.type == DisplayItem::Signal) {
            const VCDSignal& signal = item.signal.signal;
            QString value = getSignalValueAtTime(signal.identifier, cursorTime);
            
            // Format the value based on signal type
            QString displayValue;
            if (signal.width > 1) {
                displayValue = formatBusValue(value);
            } else {
                displayValue = value.toUpper();
            }
            
            painter.setPen(QPen(Qt::white));
            painter.drawText(valuesColumnStart + 5, currentY + itemHeight / 2 + 4, displayValue);
        }
        
        // Draw horizontal separator
        painter.setPen(QPen(QColor(80, 80, 80)));
        painter.drawLine(valuesColumnStart, currentY + itemHeight, 
                        valuesColumnStart + valuesColumnWidth, currentY + itemHeight);
        
        currentY += itemHeight;
    }
}



void WaveformWidget::drawWaveformArea(QPainter &painter) {
    int waveformStartX = signalNamesWidth + valuesColumnWidth;
    painter.setClipRect(waveformStartX, 0, width() - waveformStartX, height());
    painter.translate(waveformStartX, 0);
    painter.fillRect(0, 0, width() - waveformStartX, height(), QColor(30, 30, 30));
    
    if (!displayItems.isEmpty()) {
        drawGrid(painter);
        drawSignals(painter);
    }
    
    painter.translate(-waveformStartX, 0);
    painter.setClipping(false);
}

void WaveformWidget::drawTimeCursor(QPainter &painter)
{
    if (!showCursor || cursorTime < 0) return;
    
    int waveformStartX = signalNamesWidth + valuesColumnWidth;
    int cursorX = timeToX(cursorTime);
    
    // Draw vertical cursor line only in waveform area
    painter.setPen(QPen(Qt::yellow, 2, Qt::DashLine));
    painter.drawLine(waveformStartX + cursorX, 0, waveformStartX + cursorX, height());
    
    // Draw cursor time label at top
    painter.setPen(QPen(Qt::white));
    QString timeText = QString("Time: %1").arg(cursorTime);
    QRect timeRect(waveformStartX + cursorX + 5, 5, 100, 20);
    painter.fillRect(timeRect, QColor(0, 0, 0, 200));
    painter.drawText(timeRect, Qt::AlignLeft | Qt::AlignVCenter, timeText);
}

void WaveformWidget::drawGrid(QPainter &painter)
{
    painter.setPen(QPen(QColor(80, 80, 80), 1, Qt::DotLine));

    int startTime = xToTime(0);
    int endTime = xToTime(width() - signalNamesWidth - valuesColumnWidth);

    int timeStep = calculateTimeStep(startTime, endTime);
    for (int time = (startTime / timeStep) * timeStep; time <= endTime; time += timeStep)
    {
        int x = timeToX(time);
        painter.drawLine(x, 0, x, height());

        painter.setPen(QPen(Qt::white));
        painter.drawText(x + 2, timeMarkersHeight - 5, QString::number(time));
        painter.setPen(QPen(QColor(80, 80, 80), 1, Qt::DotLine));
    }

    // Draw horizontal lines for items
    int currentY = topMargin + timeMarkersHeight;
    for (int i = 0; i <= displayItems.size(); i++)
    {
        painter.drawLine(0, currentY, width() - signalNamesWidth - valuesColumnWidth, currentY);
        if (i < displayItems.size()) {
            currentY += displayItems[i].getHeight();
        }
    }

    // Draw selection highlight for all selected items
    currentY = topMargin + timeMarkersHeight;
    for (int i = 0; i < displayItems.size(); i++)
    {
        int itemHeight = displayItems[i].getHeight();
        if (selectedItems.contains(i))
        {
            painter.fillRect(0, currentY, width() - signalNamesWidth - valuesColumnWidth, itemHeight, QColor(60, 60, 90));
        }
        currentY += itemHeight;
    }
}


void WaveformWidget::drawSignals(QPainter &painter) {
    int currentY = topMargin + timeMarkersHeight;
    
    for (int i = 0; i < displayItems.size(); i++) {
        const auto& item = displayItems[i];
        int itemHeight = item.getHeight();
        
        if (item.type == DisplayItem::Signal) {
            const VCDSignal& signal = item.signal.signal;
            
            // Draw as bus if width > 1, otherwise as single line
            if (signal.width > 1) {
                drawBusWaveform(painter, signal, currentY);
            } else {
                drawSignalWaveform(painter, signal, currentY);
            }
        }
        
        currentY += itemHeight;
    }
}




void WaveformWidget::drawSignalWaveform(QPainter &painter, const VCDSignal &signal, int yPos) {
    const auto &changes = vcdParser->getValueChanges().value(signal.identifier);
    if (changes.isEmpty()) return;

    QColor signalColor = getSignalColor(signal.identifier);
    
    int signalMidY = yPos + 15;
    int highLevel = yPos + 5;
    int lowLevel = yPos + 25;
    int middleLevel = yPos + 15; // Middle level for X/Z values

    int prevTime = 0;
    QString prevValue = "0";
    int prevX = timeToX(prevTime);

    for (const auto &change : changes) {
        int currentX = timeToX(change.timestamp);
        
        // Handle X and Z values with special colors and levels
        QColor drawColor = signalColor;
        bool isX = (change.value == "x" || change.value == "X");
        bool isZ = (change.value == "z" || change.value == "Z");
        bool prevIsX = (prevValue == "x" || prevValue == "X");
        bool prevIsZ = (prevValue == "z" || prevValue == "Z");
        
        if (isX) {
            drawColor = QColor(255, 0, 0); // Red for X
        } else if (isZ) {
            drawColor = QColor(255, 165, 0); // Orange for Z
        }
        
        painter.setPen(QPen(drawColor, 2));

        // Draw the segment based on previous value
        if (prevIsX || prevIsZ) {
            // Previous value was X or Z - draw at middle level
            painter.drawLine(prevX, middleLevel, currentX, middleLevel);
        } else if (prevValue == "1") {
            painter.drawLine(prevX, highLevel, currentX, highLevel);
        } else {
            painter.drawLine(prevX, lowLevel, currentX, lowLevel);
        }

        // Draw transition line if value changed
        if (prevValue != change.value) {
            int fromY, toY;
            
            // Determine starting Y position
            if (prevIsX || prevIsZ) {
                fromY = middleLevel;
            } else if (prevValue == "1") {
                fromY = highLevel;
            } else {
                fromY = lowLevel;
            }
            
            // Determine ending Y position  
            if (isX || isZ) {
                toY = middleLevel;
            } else if (change.value == "1") {
                toY = highLevel;
            } else {
                toY = lowLevel;
            }
            
            painter.drawLine(currentX, fromY, currentX, toY);
        }

        prevTime = change.timestamp;
        prevValue = change.value;
        prevX = currentX;
    }

    // Draw the final segment
    QColor finalColor = signalColor;
    bool finalIsX = (prevValue == "x" || prevValue == "X");
    bool finalIsZ = (prevValue == "z" || prevValue == "Z");
    
    if (finalIsX) {
        finalColor = QColor(255, 0, 0);
    } else if (finalIsZ) {
        finalColor = QColor(255, 165, 0);
    }
    
    painter.setPen(QPen(finalColor, 2));
    
    int endX = timeToX(vcdParser->getEndTime());
    
    if (finalIsX || finalIsZ) {
        painter.drawLine(prevX, middleLevel, endX, middleLevel);
    } else if (prevValue == "1") {
        painter.drawLine(prevX, highLevel, endX, highLevel);
    } else {
        painter.drawLine(prevX, lowLevel, endX, lowLevel);
    }
}

void WaveformWidget::drawBusWaveform(QPainter &painter, const VCDSignal &signal, int yPos) {
    const auto &changes = vcdParser->getValueChanges().value(signal.identifier);
    if (changes.isEmpty()) return;

    QColor signalColor = getSignalColor(signal.identifier);
    painter.setPen(QPen(signalColor, 2));

    int signalHeight = 25;
    int signalTop = yPos + 2;
    int signalBottom = yPos + signalHeight;
    int textY = yPos + 17; // Position for text

    int prevTime = 0;
    QString prevValue = getBusValueAtTime(signal.identifier, 0);
    int prevX = timeToX(prevTime);

    // Draw the bus background
    painter.fillRect(prevX, signalTop, width() - signalNamesWidth - valuesColumnWidth, signalHeight, QColor(40, 40, 40, 128));

    // Draw value regions and labels
    for (int i = 0; i < changes.size(); i++) {
        const auto &change = changes[i];
        int currentX = timeToX(change.timestamp);
        
        // Handle X and Z values with special colors for the region
        QColor regionColor = QColor(50, 50, 50, 180);
        QColor textColor = Qt::white;
        
        if (prevValue.contains('x') || prevValue.contains('X')) {
            regionColor = QColor(255, 0, 0, 100); // Red background for X
        } else if (prevValue.contains('z') || prevValue.contains('Z')) {
            regionColor = QColor(255, 165, 0, 100); // Orange background for Z
        }
        
        // Draw the value region
        painter.fillRect(prevX, signalTop, currentX - prevX, signalHeight, regionColor);
        
        // Draw the value text centered in this region
        if (currentX - prevX > 30) { // Only draw text if region is wide enough
            QString displayValue = formatBusValue(prevValue);
            int textWidth = painter.fontMetrics().horizontalAdvance(displayValue);
            int centerX = prevX + (currentX - prevX) / 2;
            
            painter.setPen(QPen(textColor));
            painter.drawText(centerX - textWidth/2, textY, displayValue);
            painter.setPen(QPen(signalColor, 2));
        }
        
        // Draw vertical separator at value change
        painter.drawLine(currentX, signalTop, currentX, signalBottom);
        
        prevTime = change.timestamp;
        prevValue = change.value;
        prevX = currentX;
    }

    // Draw the final region
    int endX = timeToX(vcdParser->getEndTime());
    if (endX > prevX) {
        QColor finalRegionColor = QColor(50, 50, 50, 180);
        if (prevValue.contains('x') || prevValue.contains('X')) {
            finalRegionColor = QColor(255, 0, 0, 100);
        } else if (prevValue.contains('z') || prevValue.contains('Z')) {
            finalRegionColor = QColor(255, 165, 0, 100);
        }
        
        painter.fillRect(prevX, signalTop, endX - prevX, signalHeight, finalRegionColor);
        
        if (endX - prevX > 30) {
            QString displayValue = formatBusValue(prevValue);
            int textWidth = painter.fontMetrics().horizontalAdvance(displayValue);
            int centerX = prevX + (endX - prevX) / 2;
            
            painter.setPen(QPen(Qt::white));
            painter.drawText(centerX - textWidth/2, textY, displayValue);
        }
    }

    // Draw bus outline with signal color
    painter.setPen(QPen(signalColor, 2));
    painter.drawRect(timeToX(0), signalTop, endX - timeToX(0), signalHeight);
}

void WaveformWidget::updateScrollBar()
{
    if (!vcdParser)
    {
        horizontalScrollBar->setRange(0, 0);
        return;
    }

    int contentWidth = timeToX(vcdParser->getEndTime());
    int viewportWidth = width() - signalNamesWidth - valuesColumnWidth;

    horizontalScrollBar->setRange(0, qMax(0, contentWidth - viewportWidth));
    horizontalScrollBar->setPageStep(viewportWidth);
    horizontalScrollBar->setSingleStep(viewportWidth / 10);

    horizontalScrollBar->setGeometry(signalNamesWidth + valuesColumnWidth, height() - 20, width() - signalNamesWidth - valuesColumnWidth, 20);
}

int WaveformWidget::timeToX(int time) const
{
    return static_cast<int>(time * timeScale) - timeOffset;
}

int WaveformWidget::xToTime(int x) const
{
    return static_cast<int>((x + timeOffset) / timeScale);
}

QString WaveformWidget::getSignalValueAtTime(const QString &identifier, int time) const
{
    const auto &changes = vcdParser->getValueChanges().value(identifier);
    QString value = "0";

    for (const auto &change : changes)
    {
        if (change.timestamp > time)
            break;
        value = change.value;
    }

    return value;
}

QString WaveformWidget::getBusValueAtTime(const QString &identifier, int time) const {
    const auto &changes = vcdParser->getValueChanges().value(identifier);
    QString value = "0"; // Default value

    for (const auto &change : changes) {
        if (change.timestamp > time)
            break;
        value = change.value;
    }

    return value;
}

int WaveformWidget::calculateTimeStep(int startTime, int endTime) const
{
    int timeRange = endTime - startTime;
    if (timeRange <= 0)
        return 100;

    double pixelsPerStep = 100.0;
    double targetStep = pixelsPerStep / timeScale;

    double power = std::pow(10, std::floor(std::log10(targetStep)));
    double normalized = targetStep / power;

    if (normalized < 1.5)
        return static_cast<int>(power);
    else if (normalized < 3)
        return static_cast<int>(2 * power);
    else if (normalized < 7)
        return static_cast<int>(5 * power);
    else
        return static_cast<int>(10 * power);
}

void WaveformWidget::handleMultiSelection(int itemIndex, QMouseEvent *event)
{
    if (itemIndex < 0 || itemIndex >= displayItems.size()) return;

    if (event->modifiers() & Qt::ShiftModifier && lastSelectedItem != -1) {
        // Shift-click: select range from last selected to current
        selectedItems.clear();
        int start = qMin(lastSelectedItem, itemIndex);
        int end = qMax(lastSelectedItem, itemIndex);
        for (int i = start; i <= end; i++) {
            selectedItems.insert(i);
        }
    } else if (event->modifiers() & Qt::ControlModifier) {
        // Ctrl-click: toggle selection
        if (selectedItems.contains(itemIndex)) {
            selectedItems.remove(itemIndex);
        } else {
            selectedItems.insert(itemIndex);
        }
        lastSelectedItem = itemIndex;
    } else {
        // Regular click: single selection
        selectedItems.clear();
        selectedItems.insert(itemIndex);
        lastSelectedItem = itemIndex;
    }
    
    update();
    emit itemSelected(itemIndex);
}

int WaveformWidget::getItemYPosition(int index) const
{
    if (index < 0 || index >= displayItems.size()) return -1;
    
    int yPos = topMargin + timeMarkersHeight;
    for (int i = 0; i < index; i++) {
        yPos += displayItems[i].getHeight();
    }
    return yPos;
}

void WaveformWidget::startDrag(int itemIndex)
{
    if (itemIndex < 0 || itemIndex >= displayItems.size()) return;
    
    isDraggingItem = true;
    dragItemIndex = itemIndex;
    dragStartPos = QCursor::pos();
    dragStartY = getItemYPosition(itemIndex);
    setCursor(Qt::ClosedHandCursor);
}

void WaveformWidget::performDrag(int mouseY)
{
    if (!isDraggingItem || dragItemIndex < 0) return;

    int newIndex = -1;
    int currentY = topMargin + timeMarkersHeight;
    
    // Find new position based on mouse Y
    for (int i = 0; i < displayItems.size(); i++) {
        int itemHeight = displayItems[i].getHeight();
        if (mouseY >= currentY && mouseY < currentY + itemHeight) {
            newIndex = i;
            break;
        }
        currentY += itemHeight;
    }
    
    if (newIndex == -1) newIndex = displayItems.size() - 1;
    if (newIndex == dragItemIndex) return;

    moveItem(dragItemIndex, newIndex);
}

void WaveformWidget::moveItem(int itemIndex, int newIndex)
{
    DisplayItem item = displayItems[itemIndex];
    displayItems.removeAt(itemIndex);
    
    // Adjust new index if we're moving past the original position
    if (newIndex > itemIndex) newIndex--;
    
    displayItems.insert(newIndex, item);
    dragItemIndex = newIndex;
    
    // Update selection
    if (selectedItems.contains(itemIndex)) {
        selectedItems.remove(itemIndex);
        selectedItems.insert(newIndex);
        lastSelectedItem = newIndex;
    }
    
    update();
}


void WaveformWidget::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        if (isOverNamesSplitter(event->pos())) {
            draggingNamesSplitter = true;
            setCursor(Qt::SplitHCursor);
            event->accept();
            return;
        } else if (isOverValuesSplitter(event->pos())) {
            draggingValuesSplitter = true;
            setCursor(Qt::SplitHCursor);
            event->accept();
            return;
        }
    }

    // Check if click is in timeline area (top part of waveform area)
    int waveformStartX = signalNamesWidth + valuesColumnWidth;
    bool inTimelineArea = event->pos().x() >= waveformStartX && 
                         event->pos().y() < timeMarkersHeight;

    if (event->button() == Qt::LeftButton && inTimelineArea) {
        updateCursorTime(event->pos());
        event->accept();
        return;
    }

    // Check if click is in signal names column or waveform area
    bool inNamesColumn = event->pos().x() < signalNamesWidth;
    bool inWaveformArea = event->pos().x() >= waveformStartX;

    if (event->button() == Qt::MiddleButton)
    {
        // Start middle button drag for horizontal scrolling (waveform area only)
        if (!inNamesColumn && inWaveformArea)
        {
            isDragging = true;
            dragStartX = event->pos().x() - waveformStartX;
            dragStartOffset = timeOffset;
            setCursor(Qt::ClosedHandCursor);
        }
    }
    else if (event->button() == Qt::LeftButton)
    {
        int itemIndex = getItemAtPosition(event->pos());

        if (itemIndex >= 0)
        {
            // Handle multi-selection
            handleMultiSelection(itemIndex, event);

            // Prepare for drag
            startDrag(itemIndex);
            update();
            emit itemSelected(itemIndex);
        }
        else if (!inNamesColumn && inWaveformArea)
        {
            // Clear selection when clicking empty space
            if (!(event->modifiers() & (Qt::ControlModifier | Qt::ShiftModifier)))
            {
                selectedItems.clear();
                lastSelectedItem = -1;
                update();
                emit itemSelected(-1);
            }

            // Start timeline dragging with left button (waveform area only)
            isDragging = true;
            dragStartX = event->pos().x() - waveformStartX;
            dragStartOffset = timeOffset;
            setCursor(Qt::ClosedHandCursor);
        }
    }
}

void WaveformWidget::mouseDoubleClickEvent(QMouseEvent *event)
{
    int itemIndex = getItemAtPosition(event->pos());
    if (itemIndex >= 0) {
        if (isSpaceItem(itemIndex)) {
            renameItem(itemIndex);
            event->accept();
            return;
        }
    }
    QWidget::mouseDoubleClickEvent(event);
}

void WaveformWidget::mouseMoveEvent(QMouseEvent *event)
{
    if (draggingNamesSplitter) {
        signalNamesWidth = qMax(150, event->pos().x());
        updateSplitterPositions();
    } else if (draggingValuesSplitter) {
        valuesColumnWidth = qMax(80, event->pos().x() - signalNamesWidth);
        updateSplitterPositions();
    } else {
        // Update cursor when over splitter
        if (isOverNamesSplitter(event->pos()) || isOverValuesSplitter(event->pos())) {
            setCursor(Qt::SplitHCursor);
        } else {
            setCursor(Qt::ArrowCursor);
        }

        if (isDraggingItem) {
            performDrag(event->pos().y());
        } else if (isDragging) {
            int waveformStartX = signalNamesWidth + valuesColumnWidth;
            int delta = dragStartX - (event->pos().x() - waveformStartX);
            timeOffset = dragStartOffset + delta;
            updateScrollBar();
            update();
        }

        // Emit time change for cursor position in waveform area
        int waveformStartX = signalNamesWidth + valuesColumnWidth;
        if (event->pos().x() >= waveformStartX) {
            int currentTime = xToTime(event->pos().x() - waveformStartX);
            emit timeChanged(currentTime);
        }
    }
}

void WaveformWidget::mouseReleaseEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton && (draggingNamesSplitter || draggingValuesSplitter)) {
        draggingNamesSplitter = false;
        draggingValuesSplitter = false;
        setCursor(Qt::ArrowCursor);
        event->accept();
        return;
    }

    if (event->button() == Qt::MiddleButton || event->button() == Qt::LeftButton)
    {
        if (isDraggingItem)
        {
            isDraggingItem = false;
            dragItemIndex = -1;
            setCursor(Qt::ArrowCursor);
        }
        else if (isDragging)
        {
            isDragging = false;
            setCursor(Qt::ArrowCursor);
        }
    }
}

void WaveformWidget::keyPressEvent(QKeyEvent *event)
{
    if (event->key() == Qt::Key_A && event->modifiers() & Qt::ControlModifier)
    {
        selectAllSignals();
        event->accept();
    }
    else if (event->key() == Qt::Key_Delete)
    {
        removeSelectedSignals();
        event->accept();
    }
    else if (event->key() == Qt::Key_Escape && isSearchActive)
    {
        // Clear search on Escape
        handleSearchInput("");
        event->accept();
    }
    else if (event->key() == Qt::Key_Backspace)
    {
        // Handle backspace in search
        if (isSearchActive) {
            handleSearchInput(searchText.left(searchText.length() - 1));
            event->accept();
        } else {
            QWidget::keyPressEvent(event);
        }
    }
    else if (!event->text().isEmpty() && event->text().at(0).isPrint())
    {
        // Handle regular text input for search
        if (!isSearchActive) {
            // Start new search
            handleSearchInput(event->text());
        } else {
            // Append to existing search
            handleSearchInput(searchText + event->text());
        }
        event->accept();
    }
    else
    {
        QWidget::keyPressEvent(event);
    }
}


void WaveformWidget::wheelEvent(QWheelEvent *event)
{
    if (event->modifiers() & Qt::ControlModifier)
    {
        // Ctrl + Wheel for zoom
        if (event->angleDelta().y() > 0)
        {
            zoomIn();
        }
        else
        {
            zoomOut();
        }
    }
    else if (event->modifiers() & Qt::ShiftModifier)
    {
        // Shift + Wheel for horizontal scrolling
        int scrollAmount = event->angleDelta().y();
        timeOffset += scrollAmount / 2;
        updateScrollBar();
        update();
    }
    else
    {
        QWidget::wheelEvent(event);
    }
}

void WaveformWidget::contextMenuEvent(QContextMenuEvent *event)
{
    int itemIndex = getItemAtPosition(event->pos());
    showContextMenu(event->globalPos(), itemIndex);
}

void WaveformWidget::resizeEvent(QResizeEvent *event)
{
    Q_UNUSED(event)
    updateScrollBar();
}

int WaveformWidget::getItemAtPosition(const QPoint &pos) const
{
    if (displayItems.isEmpty())
        return -1;

    int y = pos.y();
    int signalAreaTop = topMargin + timeMarkersHeight;

    if (y < signalAreaTop)
        return -1;

    int currentY = signalAreaTop;
    for (int i = 0; i < displayItems.size(); i++)
    {
        int itemHeight = displayItems[i].getHeight();
        if (y >= currentY && y < currentY + itemHeight)
            return i;
        currentY += itemHeight;
    }

    return -1;
}

QString WaveformWidget::promptForName(const QString &title, const QString &defaultName)
{
    bool ok;
    QString name = QInputDialog::getText(this, title, "Name:", QLineEdit::Normal, defaultName, &ok);
    if (ok) {
        return name;
    }
    return defaultName;
}

void WaveformWidget::addSpaceAbove(int index)
{
    if (index < 0 || index >= displayItems.size()) return;
    
    QString name = promptForName("Add Space", "");
    displayItems.insert(index, DisplayItem::createSpace(name));
    update();
}

void WaveformWidget::addSpaceBelow(int index)
{
    if (index < 0 || index >= displayItems.size()) return;
    
    QString name = promptForName("Add Space", "");
    int insertIndex = index + 1;
    if (insertIndex > displayItems.size()) {
        insertIndex = displayItems.size();
    }
    
    displayItems.insert(insertIndex, DisplayItem::createSpace(name));
    update();
}

void WaveformWidget::renameItem(int itemIndex)
{
    if (itemIndex < 0 || itemIndex >= displayItems.size())
        return;

    DisplayItem &item = displayItems[itemIndex];
    QString currentName = item.getName();
    QString newName = promptForName("Rename", currentName);

    if (!newName.isEmpty() && newName != currentName && item.type == DisplayItem::Space)
    {
        item.space.name = newName;
        update();
    }
}

QColor WaveformWidget::getSignalColor(const QString& identifier) const
{
    // If user has set a custom color, use it
    if (signalColors.contains(identifier)) {
        return signalColors[identifier];
    }
    
    // Default to green for all signals
    return QColor(0, 255, 0);
}

void WaveformWidget::changeSignalColor(int itemIndex)
{
    if (selectedItems.isEmpty()) return;
    
    // Get the first selected signal to use as current color reference
    QColor currentColor = Qt::green;
    for (int index : selectedItems) {
        if (isSignalItem(index)) {
            const VCDSignal& signal = displayItems[index].signal.signal;
            currentColor = getSignalColor(signal.identifier);
            break;
        }
    }
    
    QMenu colorMenu(this);
    
    // Predefined colors
    QList<QPair<QString, QColor>> predefinedColors = {
        {"Red", QColor(255, 0, 0)},
        {"Green", QColor(0, 255, 0)},
        {"Blue", QColor(0, 0, 255)},
        {"Yellow", QColor(255, 255, 0)},
        {"Cyan", QColor(0, 255, 255)},
        {"Magenta", QColor(255, 0, 255)},
        {"Orange", QColor(255, 165, 0)},
        {"Purple", QColor(128, 0, 128)},
        {"Pink", QColor(255, 192, 203)},
        {"White", QColor(255, 255, 255)}
    };
    
    for (const auto& colorPair : predefinedColors) {
        QAction *colorAction = colorMenu.addAction(colorPair.first);
        colorAction->setData(colorPair.second);
        
        // Create color icon
        QPixmap pixmap(16, 16);
        pixmap.fill(colorPair.second);
        colorAction->setIcon(QIcon(pixmap));
    }
    
    colorMenu.addSeparator();
    colorMenu.addAction("Custom Color...");
    
    // Update menu title to show how many signals are selected
    if (selectedItems.size() > 1) {
        colorMenu.setTitle(QString("Change Color for %1 Signals").arg(selectedItems.size()));
    }
    
    QAction *selectedAction = colorMenu.exec(QCursor::pos());
    
    if (selectedAction) {
        QColor newColor;
        
        if (selectedAction->text() == "Custom Color...") {
            newColor = QColorDialog::getColor(currentColor, this, 
                                           QString("Choose color for %1 signals").arg(selectedItems.size()));
            if (!newColor.isValid()) {
                return; // User cancelled
            }
        } else {
            newColor = selectedAction->data().value<QColor>();
        }
        
        // Apply the color to all selected signals
        for (int index : selectedItems) {
            if (isSignalItem(index)) {
                const VCDSignal& signal = displayItems[index].signal.signal;
                signalColors[signal.identifier] = newColor;
            }
        }
        update();
    }
}

bool WaveformWidget::isOverNamesSplitter(const QPoint &pos) const
{
    return (pos.x() >= signalNamesWidth - 3 && pos.x() <= signalNamesWidth + 3);
}

bool WaveformWidget::isOverValuesSplitter(const QPoint &pos) const
{
    int valuesColumnStart = signalNamesWidth;
    int valuesColumnEnd = valuesColumnStart + valuesColumnWidth;
    return (pos.x() >= valuesColumnEnd - 3 && pos.x() <= valuesColumnEnd + 3);
}

void WaveformWidget::updateSplitterPositions()
{
    // Ensure minimum widths
    signalNamesWidth = qMax(150, signalNamesWidth);
    valuesColumnWidth = qMax(80, valuesColumnWidth);
    
    // Ensure maximum widths
    if (signalNamesWidth + valuesColumnWidth > width() - 300) {
        valuesColumnWidth = width() - 300 - signalNamesWidth;
    }
    
    update();
}

void WaveformWidget::updateCursorTime(const QPoint &pos)
{
    int waveformStartX = signalNamesWidth + valuesColumnWidth;
    
    // Only set cursor if click is in the timeline area (top part)
    if (pos.x() < waveformStartX || pos.y() >= timeMarkersHeight) {
        return;
    }
    
    // Calculate cursor time based on the entire widget width, ignoring the left columns
    double totalWaveformWidth = width() - waveformStartX;
    double clickFraction = (double)(pos.x() - waveformStartX) / totalWaveformWidth;
    
    if (vcdParser) {
        cursorTime = clickFraction * vcdParser->getEndTime();
    } else {
        cursorTime = clickFraction * 1000; // Fallback
    }
    
    showCursor = true;
    update();
}

void WaveformWidget::showContextMenu(const QPoint &pos, int itemIndex) {
    QMenu contextMenu(this);

    if (itemIndex >= 0) {
        // Ensure the clicked item is selected if no multi-selection
        if (!selectedItems.contains(itemIndex) && selectedItems.size() <= 1) {
            selectedItems.clear();
            selectedItems.insert(itemIndex);
            lastSelectedItem = itemIndex;
            update();
        }

        // Remove option - show count if multiple selected
        QString removeText = "Remove";
        if (selectedItems.size() > 1) {
            removeText = QString("Remove %1 Signals").arg(selectedItems.size());
        } else if (isSignalItem(itemIndex)) {
            removeText = "Remove Signal";
        } else if (isSpaceItem(itemIndex)) {
            removeText = "Remove Space";
        }
        
        contextMenu.addAction(removeText, this, &WaveformWidget::removeSelectedSignals);
        contextMenu.addSeparator();

        // Color change for signals - show count if multiple selected
        bool hasSignals = false;
        for (int index : selectedItems) {
            if (isSignalItem(index)) {
                hasSignals = true;
                break;
            }
        }
        
        if (hasSignals) {
            QString colorText = "Change Color";
            if (selectedItems.size() > 1) {
                colorText = QString("Change Color for %1 Signals").arg(selectedItems.size());
            }
            contextMenu.addAction(colorText, this, [this, itemIndex]() {
                changeSignalColor(itemIndex);
            });
            contextMenu.addSeparator();
        }

        // Rename for spaces (only if single space selected)
        if (isSpaceItem(itemIndex) && selectedItems.size() == 1) {
            contextMenu.addAction("Rename", this, [this, itemIndex]() {
                renameItem(itemIndex);
            });
            contextMenu.addSeparator();
        }

        // Bus display options (only show if any multi-bit signals are selected)
        bool hasMultiBitSignals = false;
        for (int index : selectedItems) {
            if (isSignalItem(index) && getSignalFromItem(index).width > 1) {
                hasMultiBitSignals = true;
                break;
            }
        }
        
        if (hasMultiBitSignals) {
            QMenu* busFormatMenu = contextMenu.addMenu("Bus Display Format");
            
            QAction* hexAction = busFormatMenu->addAction("Hexadecimal", [this]() {
                setBusDisplayFormat(WaveformWidget::Hex);
            });
            QAction* binAction = busFormatMenu->addAction("Binary", [this]() {
                setBusDisplayFormat(WaveformWidget::Binary);
            });
            QAction* octAction = busFormatMenu->addAction("Octal", [this]() {
                setBusDisplayFormat(WaveformWidget::Octal);
            });
            QAction* decAction = busFormatMenu->addAction("Decimal", [this]() {
                setBusDisplayFormat(WaveformWidget::Decimal);
            });
            
            hexAction->setCheckable(true);
            binAction->setCheckable(true);
            octAction->setCheckable(true);
            decAction->setCheckable(true);
            
            hexAction->setChecked(busDisplayFormat == Hex);
            binAction->setChecked(busDisplayFormat == Binary);
            octAction->setChecked(busDisplayFormat == Octal);
            decAction->setChecked(busDisplayFormat == Decimal);
            
            contextMenu.addSeparator();
        }

        // Space management
        contextMenu.addAction("Add Space Above", this, [this, itemIndex]() {
            addSpaceAbove(itemIndex);
        });
        contextMenu.addAction("Add Space Below", this, [this, itemIndex]() {
            addSpaceBelow(itemIndex);
        });
    } else {
        // Global bus display options when clicking empty space
        QMenu* busFormatMenu = contextMenu.addMenu("Bus Display Format");
        
        QAction* hexAction = busFormatMenu->addAction("Hexadecimal", [this]() {
            setBusDisplayFormat(WaveformWidget::Hex);
        });
        QAction* binAction = busFormatMenu->addAction("Binary", [this]() {
            setBusDisplayFormat(WaveformWidget::Binary);
        });
        QAction* octAction = busFormatMenu->addAction("Octal", [this]() {
            setBusDisplayFormat(WaveformWidget::Octal);
        });
        QAction* decAction = busFormatMenu->addAction("Decimal", [this]() {
            setBusDisplayFormat(WaveformWidget::Decimal);
        });
        
        hexAction->setCheckable(true);
        binAction->setCheckable(true);
        octAction->setCheckable(true);
        decAction->setCheckable(true);
        
        hexAction->setChecked(busDisplayFormat == Hex);
        binAction->setChecked(busDisplayFormat == Binary);
        octAction->setChecked(busDisplayFormat == Octal);
        decAction->setChecked(busDisplayFormat == Decimal);
    }

    QAction* selectedAction = contextMenu.exec(pos);
    if (!selectedAction && itemIndex >= 0 && selectedItems.size() <= 1) {
        // Restore selection if menu was cancelled and only single item was selected
        selectedItems.clear();
        selectedItems.insert(itemIndex);
        update();
    }

    emit contextMenuRequested(pos, itemIndex);
}

QString WaveformWidget::formatBusValue(const QString& binaryValue) const {
    if (binaryValue.isEmpty()) return "x";
    
    // Handle special cases
    if (binaryValue == "x" || binaryValue == "X") return "x";
    if (binaryValue == "z" || binaryValue == "Z") return "z";
    
    // Check if it's a valid binary string
    if (!isValidBinary(binaryValue)) {
        return binaryValue; // Return as-is if not pure binary
    }
    
    switch(busDisplayFormat) {
        case Hex: return binaryToHex(binaryValue);
        case Binary: return binaryValue;
        case Octal: return binaryToOctal(binaryValue);
        case Decimal: return binaryToDecimal(binaryValue);
        default: return binaryToHex(binaryValue);
    }
}

bool WaveformWidget::isValidBinary(const QString& value) const {
    for (QChar ch : value) {
        if (ch != '0' && ch != '1') {
            return false;
        }
    }
    return true;
}

QString WaveformWidget::binaryToHex(const QString& binaryValue) const {
    if (binaryValue.isEmpty()) return "0";
    
    // Convert binary string to integer
    bool ok;
    unsigned long long value = binaryValue.toULongLong(&ok, 2);
    
    if (!ok) {
        return "x"; // Conversion failed
    }
    
    // Calculate number of hex digits needed
    int bitCount = binaryValue.length();
    int hexDigits = (bitCount + 3) / 4; // ceil(bitCount / 4)
    
    // Format as hex with appropriate number of digits
    return "0x" + QString::number(value, 16).rightJustified(hexDigits, '0').toUpper();
}

QString WaveformWidget::binaryToOctal(const QString& binaryValue) const {
    if (binaryValue.isEmpty()) return "0";
    
    // Convert binary to octal
    QString octal;
    QString paddedBinary = binaryValue;
    
    // Pad with zeros to make length multiple of 3
    while (paddedBinary.length() % 3 != 0) {
        paddedBinary = "0" + paddedBinary;
    }
    
    for (int i = 0; i < paddedBinary.length(); i += 3) {
        QString chunk = paddedBinary.mid(i, 3);
        int decimal = chunk.toInt(nullptr, 2);
        octal += QString::number(decimal);
    }
    
    return "0" + octal;
}

QString WaveformWidget::binaryToDecimal(const QString& binaryValue) const {
    if (binaryValue.isEmpty()) return "0";
    
    bool ok;
    unsigned long long value = binaryValue.toULongLong(&ok, 2);
    
    if (!ok) {
        return "x"; // Conversion failed
    }
    
    return QString::number(value);
}

void WaveformWidget::drawSearchBar(QPainter &painter)
{
    int searchBarHeight = 25;
    
    // Draw search bar background
    painter.fillRect(0, timeMarkersHeight, signalNamesWidth, searchBarHeight, QColor(70, 70, 80));
    
    // Draw search icon or label
    painter.setPen(QPen(Qt::white));
    painter.drawText(5, timeMarkersHeight + searchBarHeight - 8, "🔍");
    
    // Draw search text
    if (searchText.isEmpty()) {
        painter.setPen(QPen(QColor(180, 180, 180)));
        painter.drawText(25, timeMarkersHeight + searchBarHeight - 8, "Search signals...");
    } else {
        painter.setPen(QPen(Qt::white));
        painter.drawText(25, timeMarkersHeight + searchBarHeight - 8, searchText);
        
        // Draw result count
        if (!searchResults.isEmpty()) {
            QString resultText = QString("(%1)").arg(searchResults.size());
            int textWidth = painter.fontMetrics().horizontalAdvance(resultText);
            painter.drawText(signalNamesWidth - textWidth - 5, timeMarkersHeight + searchBarHeight - 8, resultText);
        }
    }
    
    // Update top margin to account for search bar
    topMargin = searchBarHeight;
}

void WaveformWidget::handleSearchInput(const QString &text)
{
    searchText = text;
    isSearchActive = !searchText.isEmpty();
    updateSearchResults();
    update();
}

void WaveformWidget::updateSearchResults()
{
    searchResults.clear();
    
    if (!isSearchActive || searchText.isEmpty()) {
        // If no search, show all signals
        for (int i = 0; i < displayItems.size(); i++) {
            if (displayItems[i].type == DisplayItem::Signal) {
                searchResults.insert(i);
            }
        }
    } else {
        // Filter signals based on search text
        QString searchLower = searchText.toLower();
        for (int i = 0; i < displayItems.size(); i++) {
            if (displayItems[i].type == DisplayItem::Signal) {
                QString signalName = displayItems[i].getFullPath().toLower();
                if (signalName.contains(searchLower)) {
                    searchResults.insert(i);
                }
            }
        }
    }
    
    qDebug() << "Search results:" << searchResults;
    applySearchFilter();
}


void WaveformWidget::applySearchFilter()
{
    if (isSearchActive) {
        // Only select search results, don't filter them out
        selectedItems = searchResults;
        if (!selectedItems.isEmpty()) {
            lastSelectedItem = *selectedItems.begin();
        } else {
            lastSelectedItem = -1;
        }
    } else {
        // Clear selection when search is inactive
        selectedItems.clear();
        lastSelectedItem = -1;
    }
    update();
    emit itemSelected(lastSelectedItem);
}# File: CMakeLists.txt
cmake_minimum_required(VERSION 3.16)

project(OWV VERSION 0.1 LANGUAGES CXX)

set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(QT NAMES Qt6 Qt5 REQUIRED COMPONENTS Widgets)
find_package(Qt${QT_VERSION_MAJOR} REQUIRED COMPONENTS Widgets)

set(PROJECT_SOURCES
        main.cpp
        mainwindow.cpp
        mainwindow.h
        mainwindow.ui
)

if(${QT_VERSION_MAJOR} GREATER_EQUAL 6)
    qt_add_executable(OWV
        MANUAL_FINALIZATION
        ${PROJECT_SOURCES}
        vcdparser.cpp
        vcdparser.h
        waveformwidget.cpp
        waveformwidget.h
        SignalSelectionDialog.h
        SignalSelectionDialog.cpp
    )
# Define target properties for Android with Qt 6 as:
#    set_property(TARGET OWV APPEND PROPERTY QT_ANDROID_PACKAGE_SOURCE_DIR
#                 ${CMAKE_CURRENT_SOURCE_DIR}/android)
# For more information, see https://doc.qt.io/qt-6/qt-add-executable.html#target-creation
else()
    if(ANDROID)
        add_library(OWV SHARED
            ${PROJECT_SOURCES}
        )
# Define properties for Android with Qt 5 after find_package() calls as:
#    set(ANDROID_PACKAGE_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/android")
    else()
        add_executable(OWV
            ${PROJECT_SOURCES}
        )
    endif()
endif()

target_link_libraries(OWV PRIVATE Qt${QT_VERSION_MAJOR}::Widgets)

# Qt for iOS sets MACOSX_BUNDLE_GUI_IDENTIFIER automatically since Qt 6.1.
# If you are developing for iOS or macOS you should consider setting an
# explicit, fixed bundle identifier manually though.
if(${QT_VERSION} VERSION_LESS 6.1.0)
  set(BUNDLE_ID_OPTION MACOSX_BUNDLE_GUI_IDENTIFIER com.example.OWV)
endif()
set_target_properties(OWV PROPERTIES
    ${BUNDLE_ID_OPTION}
    MACOSX_BUNDLE_BUNDLE_VERSION ${PROJECT_VERSION}
    MACOSX_BUNDLE_SHORT_VERSION_STRING ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}
    MACOSX_BUNDLE TRUE
    WIN32_EXECUTABLE TRUE
)

include(GNUInstallDirs)
install(TARGETS OWV
    BUNDLE DESTINATION .
    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)

if(QT_VERSION_MAJOR EQUAL 6)
    qt_finalize_executable(OWV)
endif()
